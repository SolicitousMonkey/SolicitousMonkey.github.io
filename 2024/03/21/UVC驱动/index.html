<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="UVC驱动"><meta name="keywords" content="uvc驱动"><meta name="author" content="郑伟铭"><meta name="copyright" content="郑伟铭"><title>UVC驱动 | zwm's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#uvc%E4%B8%8Ev4l2%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">1.0.1.</span> <span class="toc-text">uvc与v4l2的关系：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#file-opeaation%E5%92%8Cprobe%EF%BC%9A"><span class="toc-number">1.0.2.</span> <span class="toc-text">file_opeaation和probe：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#poll"><span class="toc-number">1.0.3.</span> <span class="toc-text">poll</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0-%E6%B3%A8%E5%86%8Cusb-driver-id-table%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%8C%B9%E9%85%8D-probe%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">入口函数 -&gt; 注册usb_driver -&gt; id_table的设置和匹配 -&gt; probe函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#probe"><span class="toc-number">3.</span> <span class="toc-text">probe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#video-device"><span class="toc-number">4.</span> <span class="toc-text">video_device</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#video-device%E4%B8%AD%E7%9A%84fops%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">video_device中的fops：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fops%E4%B8%AD%E7%9A%84mmap"><span class="toc-number">5.1.</span> <span class="toc-text">fops中的mmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fops%E4%B8%AD%E7%9A%84poll"><span class="toc-number">5.2.</span> <span class="toc-text">fops中的poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fops%E4%B8%AD%E7%9A%84video-ioctl2"><span class="toc-number">5.3.</span> <span class="toc-text">fops中的video_ioctl2</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#V4L2-ioctl%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">5.3.1.</span> <span class="toc-text">V4L2 ioctl处理流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#video-device%E4%B8%AD%E7%9A%84ioctl-ops%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">video_device中的ioctl_ops：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vidioc-querycap"><span class="toc-number">6.1.</span> <span class="toc-text">vidioc_querycap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vidioc-enum-fmt-vid-cap"><span class="toc-number">6.2.</span> <span class="toc-text">vidioc_enum_fmt_vid_cap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vidioc-get-fmt-vid-cap"><span class="toc-number">6.3.</span> <span class="toc-text">vidioc_get_fmt_vid_cap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vidioc-try-fmt-vid-cap%E3%80%81sheldonUV-vidioc-set-fmt-vid-cap"><span class="toc-number">6.4.</span> <span class="toc-text">vidioc_try_fmt_vid_cap、sheldonUV_vidioc_set_fmt_vid_cap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vidioc-reqbufs"><span class="toc-number">6.5.</span> <span class="toc-text">vidioc_reqbufs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vidioc-querybuf"><span class="toc-number">6.6.</span> <span class="toc-text">vidioc_querybuf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vidioc-qbuf"><span class="toc-number">6.7.</span> <span class="toc-text">vidioc_qbuf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vidioc-dqbuf"><span class="toc-number">6.8.</span> <span class="toc-text">vidioc_dqbuf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vidioc-streamon"><span class="toc-number">6.9.</span> <span class="toc-text">vidioc_streamon</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-usb-set-interface"><span class="toc-number">6.9.1.</span> <span class="toc-text">1. usb_set_interface</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%86%E9%85%8D%E8%AE%BE%E7%BD%AEURB"><span class="toc-number">6.9.2.</span> <span class="toc-text">2. 分配设置URB</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vidioc-streamoff"><span class="toc-number">6.10.</span> <span class="toc-text">vidioc_streamoff</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpg"></div><div class="author-info__name text-center">郑伟铭</div><div class="author-info__description text-center">研究方向：深度强化学习，需求响应优化；学习方向：驱动开发</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/SolicitousMonkey">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">48</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">zwm's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">UVC驱动</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-03-21</time><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2024/03/21/UVC%E9%A9%B1%E5%8A%A8/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2024/03/21/UVC驱动/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><strong>本文要搭配源码食用，看到哪里就看源码对应的位置。</strong></p>
<h3 id="前言">前言</h3>
<h5 id="uvc与v4l2的关系：">uvc与v4l2的关系：</h5>
<p>UVC框架与V4L2的联动主要体现在UVC驱动利用V4L2 API来实现视频设备的控制和数据传输。在Linux系统中，UVC兼容设备通过UVC驱动与系统交互，UVC驱动则通过V4L2接口来提供设备操作的具体实现。这样的设计使得任何支持V4L2的应用程序都能够无缝地与UVC设备交互，无需关心设备的具体实现细节。</p>
<h5 id="file-opeaation和probe：">file_opeaation和probe：</h5>
<p>file_operation字如其名，主要是用于文件操作。具体来说，<code>file_operations</code>是一个结构体，定义了一系列指针，指向与设备文件操作相关的函数。这些函数实现了设备文件的打开、读写、定位、关闭等操作。当用户程序通过系统调用如<code>open</code>、<code>read</code>、<code>write</code>等操作设备文件时，这些系统调用最终会映射到<code>file_operations</code>中对应的函数。这</p>
<p>probe主要用来初始化设备硬件，分配资源（如内存、中断等），并注册设备，使其对系统可用。</p>
<p>当匹配的设备被发现时，probe函数被自动调用。</p>
<p><strong>为什么只有<code>probe</code>而没有<code>file_operations</code></strong>：平台设备驱动的主要任务是初始化设备、设置硬件参数以及注册必要的资源（如中断、内存映射等）。这类设备不一定通过文件操作接口与用户空间交互，它们可能通过其他机制（如内核定时器、中断处理）进行操作，因此不一定需要实现<code>file_operations</code>。</p>
<p><strong>为什么有<code>file_operations</code>而<code>probe</code>不是必需的</strong>：字符设备的主要交互方式是通过文件操作接口，因此需要实现<code>file_operations</code>结构来定义设备支持的操作（如打开、读、写）。至于<code>probe</code>函数，由于字符设备可以通过多种方式（如串口、USB等）连接到系统，它们的探测和初始化机制可能会有所不同。在某些情况下，如当设备通过标准的总线（USB、PCI等）连接时，<code>probe</code>函数用于设备的探测和初始化。然而，对于直接注册到系统的静态字符设备，可能不需要通过<code>probe</code>函数进行动态探测和初始化。</p>
<h5 id="poll">poll</h5>
<p><code>poll</code>方法主要用于非阻塞I/O操作，它使得应用程序可以在单个线程中同时监视多个文件描述符的状态，而无需为每个文件描述符创建独立的线程来阻塞读取或写入。当设备准备好进行下一步操作时（例如，数据缓冲区有足够的数据可读，或缓冲区有足够的空间可写入），<code>poll</code>方法将通知应用程序，从而提高了应用程序处理多个I/O流的效率</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> poll_table_struct *wait)</span>;</span><br></pre></td></tr></table></figure>
<p>…待补充，和select一起。</p>
<h3 id="入口函数-注册usb-driver-id-table的设置和匹配-probe函数">入口函数 -&gt; 注册usb_driver -&gt; id_table的设置和匹配 -&gt; probe函数</h3>
<p>首先从入口函数讲起</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module_init(sheldon_uvc_init);</span><br><span class="line"></span><br><span class="line">module_exit(sheldon_uvc_exit); <span class="comment">// 出口函数</span></span><br></pre></td></tr></table></figure>
<p>入口函数的作用是，当我们在系统中使用insmod装载该驱动程序时，会直接调用该入口函数</p>
<p>入口函数里有一个usb_register, 用来注册usb设备</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sheldon_uvc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//3.注册</span></span><br><span class="line">  printk(<span class="string">&quot;sheldon_uvc_init ~\n&quot;</span>);</span><br><span class="line">  usb_register(&amp;sheldon_uvc_driver);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sheldon_uvc_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;sheldon_uvc_exit ~\n&quot;</span>);</span><br><span class="line">  usb_deregister(&amp;sheldon_uvc_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册的是一个抽象出来的usb_driver结构体，<strong>sheldon_uvc_driver</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">sheldon_uvc_driver</span> =</span> &#123;</span><br><span class="line">    .name       = <span class="string">&quot;sheldon_UV&quot;</span>,</span><br><span class="line">    .probe      = sheldon_uvc_probe,</span><br><span class="line">    .disconnect = sheldon_uvc_disconnect,</span><br><span class="line">    .id_table   = sheldon_uvc_ids,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>里面包含了name，disconnect，id_table, probe等成员，系统就是根据这个id_table来绑定设备的，具体来说，当USB设备连接时，内核遍历已注册的驱动的<code>id_table</code>，通过比较<strong>设备描述符</strong>与<code>id_table</code>中的信息来确定哪个驱动支持该设备，如果匹配，那么对应的驱动就被认为支持该设备，对应的probe函数就会被调用，以初始化设备。</p>
<p>设备描述符三个信息，分别是设备类，子类、协议。id_table用USB_INTERFACE_INFO这个宏来简化USB设备的初始化。id_table如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">sheldon_uvc_ids</span>[] =</span> &#123;</span><br><span class="line">    &#123; USB_INTERFACE_INFO(USB_CLASS_VIDEO, <span class="number">1</span>, <span class="number">0</span>) &#125;,<span class="comment">/*1-视频控制接口, 三个参数分别是：设备类、子类、协议。在该定义中，三者分别是视频类，子类1，协议0*/</span></span><br><span class="line">    &#123; USB_INTERFACE_INFO(USB_CLASS_VIDEO, <span class="number">2</span>, <span class="number">0</span>) &#125;,<span class="comment">/*2-视频流控制接口(被1包含) */</span> </span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>匹配成功后，probe函数就会被调用！</p>
<h3 id="probe">probe</h3>
<p>先来看这个函数的签名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sheldon_uvc_probe</span><span class="params">(<span class="keyword">struct</span> usb_interface *intf, <span class="type">const</span> <span class="keyword">struct</span> usb_device_id *id)</span></span><br></pre></td></tr></table></figure>
<p>当UVC设备连接时，内核会自动给probe传入<code>usb_interface *intf</code>和匹配到的<code>usb_device_id *id</code>作为参数。(<code>intf</code>提供了关于当前正在连接的接口的详细信息，而<code>id</code>则指向与设备匹配的设备ID条目)</p>
<p>从intf可以获得设备和描述符的信息，设备识别是通过<code>interface_to_usbdev(intf)</code>宏，从给定的<code>usb_interface</code>结构体中提取出<code>usb_device</code>结构体。描述符是通过直接访问其<code>descriptor</code>成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据interface结构体获得usb_devce结构体，其中包含了设备描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">dev</span> =</span> interface_to_usbdev(intf);</span><br><span class="line"><span class="comment">//此处需要定义一个描述符结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device_descriptor</span> *<span class="title">descriptor</span> =</span> &amp;dev-&gt;descriptor;</span><br></pre></td></tr></table></figure>
<p>因为uvc设备有两个接口，一个是视频流控制接口，另一个是视频流接口。（也就是一个负责控制，一个复杂传输）。所以probe会被调用两次。</p>
<p>第一次调用时，主要是用一些全局的结构体或变量来保存intf的信息</p>
<p>第二次调用就比较重要了，这里着重讲一下第二次调用。</p>
<h3 id="video-device">video_device</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.分配一个video_device结构体*/</span></span><br><span class="line">sheldon_uvc_vdev = video_device_alloc();</span><br><span class="line"><span class="comment">/*2.设置*/</span></span><br><span class="line"><span class="comment">/* 2.1 */</span></span><br><span class="line">sheldon_uvc_vdev-&gt;release = sheldonUV_release;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.2 */</span></span><br><span class="line">sheldon_uvc_vdev-&gt;fops    = &amp;sheldonUV_fops;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.3 */</span></span><br><span class="line">sheldon_uvc_vdev-&gt;ioctl_ops = &amp;sheldonUV_ioctl_ops;</span><br><span class="line"><span class="comment">/*3.注册*/</span></span><br><span class="line">video_register_device(sheldon_uvc_vdev ,VFL_TYPE_GRABBER, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>首先是分配了一个video_device结构体，<code>video_device</code>是Linux内核中表示一个视频设备的核心结构体。</p>
<p>这个结构体最重要的成员就是fops和ioctl_ops.</p>
<h3 id="video-device中的fops：">video_device中的fops：</h3>
<p>先来看fops</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_file_operations</span> <span class="title">sheldonUV_fops</span> =</span> &#123;</span><br><span class="line">    .owner  = THIS_MODULE,</span><br><span class="line">    .open       = sheldonUV_open,</span><br><span class="line">    .release    = sheldonUV_close,</span><br><span class="line">    .mmap       = sheldonUV_mmap,</span><br><span class="line">    .ioctl      = video_ioctl2, <span class="comment">/* V4L2 ioctl handler -&gt; sheldonUV_ioctl_ops*/</span></span><br><span class="line">    .poll       = sheldonUV_poll,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体为视频设备提供了一组标准的文件操作接口，略过open和close操作，我们来看看mmap操作</p>
<h4 id="fops中的mmap">fops中的mmap</h4>
<p>mmap在用户程序和内核之间建立一个内存映射区域。当用户程序访问这个映射区域内的地址时，它实际上访问的是物理设备内存或内核分配的内存。这种机制使得设备I/O操作能够绕过传统的读写系统调用，提供了一种更高效的数据共享方式。（mmap可以单独开个blog）</p>
<p>它的签名是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sheldonUV_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br></pre></td></tr></table></figure>
<p>file表示打开的文件对象</p>
<p>vma表示用户空间请求映射的虚拟内存区域的结构体，包含映射区域的起始地址、结束地址、权限等信息。</p>
<p>我们知道在用户空间使用mmap时，传入的都是一些什么offset，length，flag，fd等等，并有没有什么所谓的vma，所以这个vma正是通过我们传入的参数自动生成的。内核会确保vma维护的内存区域是未被使用过的。所以，可以通过以下的方式来找出指定的缓冲区：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sheldon_uvc_queue.count; ++i) &#123;</span><br><span class="line">    buffer = &amp;sheldon_uvc_queue.buffer[i];</span><br><span class="line">    <span class="keyword">if</span> ((buffer-&gt;buf.m.offset &gt;&gt; PAGE_SHIFT) == vma-&gt;vm_pgoff)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vma-&gt;vm_pgoff就是使用mmap时传入的offset，所以找到指定缓冲区的方法就是令缓冲区的偏移量（经过页面大小移位后）与<code>vma-&gt;vm_pgoff</code>相匹配。</p>
<blockquote>
<p>举个例子，假设我们有一个简单的视频播放应用，设备驱动为每个视频帧分配了一个4KB的缓冲区，并且这些缓冲区在设备内存中是连续的。</p>
<p>假如第一个视频帧的缓冲区在设备内存的起始地址是<code>0x1000</code>（假设设备内存的起始地址是<code>0x0000</code>），那么第二个视频帧的缓冲区起始地址就是<code>0x2000</code>，因为每个缓冲区占用4KB。如果应用程序想要映射第二个视频帧的缓冲区，它可以将<code>offset</code>参数设置为<code>0x2000</code>，并调用<code>mmap</code>函数。这样，应用程序就能通过返回的地址直接访问这个视频帧的数据了。</p>
</blockquote>
<p>再然后就是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addr = (<span class="type">unsigned</span> <span class="type">long</span>)sheldon_uvc_queue.mem + buffer-&gt;buf.m.offset;</span><br><span class="line"><span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    page = vmalloc_to_page((<span class="type">void</span> *)addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把此page映射到APP对应的虚拟地址上面 */</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = vm_insert_page(vma, start, page)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    start += PAGE_SIZE;</span><br><span class="line">    addr += PAGE_SIZE;</span><br><span class="line">    size -= PAGE_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用vmalloc_to_page将虚拟地址转换为对应的物理页面，然后，通过vm_insert_page将这个物理页面映射到用户空间请求的虚拟内存地址上，循环中逐步增加<code>start</code>（映射到用户空间的起始地址）和<code>addr</code>（设备内存的当前地址），同时减少<code>size</code>（还需要映射的内存大小），直到所有请求的内存区域都被映射。（并不是offset后面的内存都会被全部映射，映射多少由mmap中的length决定）</p>
<p>最后，做一些设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vma-&gt;vm_ops = &amp;sheldon_uvc_vm_ops;</span><br><span class="line">vma-&gt;vm_private_data = buffer;</span><br><span class="line">sheldon_uvc_vm_open(vma);</span><br></pre></td></tr></table></figure>
<h4 id="fops中的poll">fops中的poll</h4>
<p>这个后面再具体补充把，想把重点ioctl先写一下，</p>
<p>先看一下这个函数的签名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sheldonUV_poll</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> poll_table_struct *wait)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>struct poll_table_struct *wait</code>：<code>poll_wait</code>函数使用的轮询表结构体，用于将当前进程加入等待队列。</li>
</ul>
<p><code>poll_wait</code>函数用于将当前进程添加到指定设备或文件的等待队列中，以等待某些事件（如可读、可写）的发生。当你在驱动的<code>poll</code>方法中调用<code>poll_wait</code>时，并不会导致代码“停”在调用点。相反，<code>poll_wait</code>的执行过程是非阻塞的；<strong>它仅仅是将当前进程挂起（添加到等待队列）</strong>，然后允许进程继续执行<code>poll</code>方法中的后续代码。</p>
<ul>
<li><strong>非阻塞</strong>：<code>poll_wait</code>本身不会阻塞进程；它仅仅是设置了一个“唤醒条件”。进程是否阻塞，取决于后续代码和系统调用的行为。</li>
<li><strong>唤醒机制</strong>：进程的实际唤醒是在后续某个时刻由内核触发的，当等待的条件（如设备的可读或可写状态）得到满足时。</li>
</ul>
<h4 id="fops中的video-ioctl2">fops中的video_ioctl2</h4>
<p><code>.ioctl</code>字段被设置为<code>video_ioctl2</code>。这表示所有的ioctl请求不是直接由设备驱动程序的某个特定函数处理，而是由V4L2框架提供的<code>video_ioctl2</code>函数处理。<code>video_ioctl2</code>函数的作用是一个中间件，它根据ioctl请求的类型（即请求码），将请求分发到一个更具体的处理函数上。这些具体的处理函数通常在驱动程序的另一个结构体中定义，称为ioctl操作集（在V4L2中，这通常是<code>v4l2_ioctl_ops</code>结构体）。</p>
<h5 id="V4L2-ioctl处理流程">V4L2 ioctl处理流程</h5>
<p>总结：<code>video_ioctl2</code>是V4L2框架提供的一个通用ioctl处理函数。它的主要作用是作为ioctl调用的中心分发点，根据ioctl请求的命令码，将请求转发到具体的处理函数上。具体来说：</p>
<ol>
<li><strong>接收请求</strong>：当应用程序通过文件描述符向设备文件发出一个ioctl请求时，内核会调用与文件描述符关联的<code>.ioctl</code>处理函数，即这里的<code>video_ioctl2</code>。</li>
<li><strong>分发请求</strong>：<code>video_ioctl2</code>函数内部包含了一个大型的switch-case语句或类似的逻辑，用于检查ioctl请求的命令码。然后，它将请求转发到<code>v4l2_ioctl_ops</code>结构体中对应的处理函数。这个结构体在驱动初始化时被设置，通常是在驱动的<code>probe</code>函数中。</li>
<li><strong>处理请求</strong>：<code>v4l2_ioctl_ops</code>结构体中包含了指向具体处理函数的指针。每个处理函数都负责处理特定的ioctl请求。例如，如果应用程序想要查询视频设备支持的格式，它会发出一个特定的ioctl请求，<code>video_ioctl2</code>会将这个请求转发到<code>v4l2_ioctl_ops</code>中指定的函数来获取支持的格式信息。</li>
</ol>
<h3 id="video-device中的ioctl-ops：">video_device中的ioctl_ops：</h3>
<p>上面fops中的video_ioctl2的请求就会被video_device中的ioctl_ops来具体实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_ioctl_ops</span> <span class="title">sheldonUV_ioctl_ops</span> =</span> &#123;</span><br><span class="line">        <span class="comment">// 表示它是一个摄像头设备</span></span><br><span class="line">        .vidioc_querycap      = sheldonUV_vidioc_querycap,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 用于列举、获得、测试、设置摄像头的数据的格式 */</span></span><br><span class="line">        .vidioc_enum_fmt_vid_cap  = sheldonUV_vidioc_enum_fmt_vid_cap,</span><br><span class="line">        .vidioc_g_fmt_vid_cap     = sheldonUV_vidioc_get_fmt_vid_cap,</span><br><span class="line">        .vidioc_try_fmt_vid_cap   = sheldonUV_vidioc_try_fmt_vid_cap,</span><br><span class="line">        .vidioc_s_fmt_vid_cap     = sheldonUV_vidioc_set_fmt_vid_cap,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 缓冲区操作: 申请/查询/放入队列/取出队列 */</span></span><br><span class="line">        .vidioc_reqbufs       = sheldonUV_vidioc_reqbufs,</span><br><span class="line">        .vidioc_querybuf      = sheldonUV_vidioc_querybuf,</span><br><span class="line">        .vidioc_qbuf          = sheldonUV_vidioc_qbuf,</span><br><span class="line">        .vidioc_dqbuf         = sheldonUV_vidioc_dqbuf,</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 查询/获得/设置属性 */</span></span><br><span class="line">        .vidioc_queryctrl     = sheldonUV_vidioc_queryctrl,</span><br><span class="line">        .vidioc_g_ctrl        = sheldonUV_vidioc_g_ctrl,</span><br><span class="line">        .vidioc_s_ctrl        = sheldonUV_vidioc_s_ctrl,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动/停止</span></span><br><span class="line">        .vidioc_streamon      = sheldonUV_vidioc_streamon,</span><br><span class="line">        .vidioc_streamoff     = sheldonUV_vidioc_streamoff,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来就是具体分析里面每一个函数的实现（可以参考源码中的uvc_v4l2_do_ioctl，路径为driver/media/usb/uvc）</p>
<h4 id="vidioc-querycap">vidioc_querycap</h4>
<p>先来看它的签名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sheldonUV_vidioc_querycap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">void</span>  *priv, <span class="keyword">struct</span> v4l2_capability *cap)</span></span><br></pre></td></tr></table></figure>
<p>这个函数的目的主要是通过驱动来告诉应用程序该uvc设备的能力，这是应用程序开始视频捕获之前必须进行的查询之一。包括但不限于下面这几条设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(cap, <span class="number">0</span>, <span class="keyword">sizeof</span> *cap);</span><br><span class="line"><span class="built_in">strcpy</span>(cap-&gt;driver, <span class="string">&quot;sheldonUV&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(cap-&gt;card, <span class="string">&quot;sheldonUV&quot;</span>);</span><br><span class="line">cap-&gt;version = <span class="number">1</span>;</span><br><span class="line">cap-&gt;capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;</span><br></pre></td></tr></table></figure>
<p>V4L2_CAP_VIDEO_CAPTURE 、V4L2_CAP_STREAMING这两个宏表明设备支持捕获和流式传输的能力。</p>
<h4 id="vidioc-enum-fmt-vid-cap">vidioc_enum_fmt_vid_cap</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sheldonUV_vidioc_enum_fmt_vid_cap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">void</span>  *priv, <span class="keyword">struct</span> v4l2_fmtdesc *f)</span></span><br></pre></td></tr></table></figure>
<p>这个函数用来枚举设备的格式，主要有几种设置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (f-&gt;index &gt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(f-&gt;description, <span class="string">&quot;4:2:2, packed, YUYV&quot;</span>);</span><br><span class="line">f-&gt;pixelformat = V4L2_PIX_FMT_YUYV;</span><br></pre></td></tr></table></figure>
<h4 id="vidioc-get-fmt-vid-cap">vidioc_get_fmt_vid_cap</h4>
<p>返回当前所使用的格式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sheldonUV_vidioc_get_fmt_vid_cap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">void</span> *priv, <span class="keyword">struct</span> v4l2_format *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(f, &amp;sheldon_uvc_format, <span class="keyword">sizeof</span>(sheldon_uvc_format));</span><br><span class="line"> 	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h4 id="vidioc-try-fmt-vid-cap、sheldonUV-vidioc-set-fmt-vid-cap">vidioc_try_fmt_vid_cap、sheldonUV_vidioc_set_fmt_vid_cap</h4>
<p>先略过，想先看重点reqbufs部分</p>
<h4 id="vidioc-reqbufs">vidioc_reqbufs</h4>
<p>这个函数用来处理VIDIOC_REQBUFS的ioctl请求，用于为视频捕获分配一定数量的缓冲区，或者释放之前分配的所有缓冲区。</p>
<p>简单来说，就是先分配一整块大内存，然后用定义的队列将其划分为多个部分，每个部分对应一个缓冲区，从而实现缓冲区队列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sheldonUV_vidioc_reqbufs</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">void</span> *priv, <span class="keyword">struct</span> v4l2_requestbuffers *p)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>struct v4l2_requestbuffers *p</code>：指向<code>v4l2_requestbuffers</code>结构的指针，该结构包含请求缓冲区的详细信息，如缓冲区数量、类型、内存分配模式等。</li>
</ul>
<ol>
<li><strong>释放之前的缓冲区</strong>：用sheldon_uvc_free_buffers释放之前分配的所有缓冲区</li>
<li>如果请求的缓冲区数量为0，则不进行任何分配，直接完成</li>
<li><strong>缓冲区分配</strong>：使用vmalloc_32尝试分配所需数量的缓冲区。如果分配失败，逐渐减少请求的缓冲区数量并重试，直到成功分配或数量减至0。这里使用的PAGE_ALIGN确保每个缓冲区大小对齐到页面大小，有利于内存管理和性能优化。</li>
<li><strong>初始化缓冲区队列</strong>：使用<code>INIT_LIST_HEAD</code>初始化缓冲区队列的头部，准备用于管理缓冲区。</li>
<li><strong>设置缓冲区属性</strong>：对于每个成功分配的缓冲区，设置其属性（如索引、偏移量、长度、类型等），并初始化等待队列头。</li>
<li><strong>记录分配信息</strong>：保存分配的内存指针、缓冲区数量和每个缓冲区的大小到<code>sheldon_uvc_queue</code>结构中，以便于后续管理和使用。</li>
</ol>
<p>配置队列的代码还是很优雅的，贴上来欣赏一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这些缓存是一次性作为一个整体来分配的 */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sheldon_uvc_queue, <span class="number">0</span>, <span class="keyword">sizeof</span>(sheldon_uvc_queue));</span><br><span class="line"></span><br><span class="line">INIT_LIST_HEAD(&amp;sheldon_uvc_queue.mainqueue);</span><br><span class="line">INIT_LIST_HEAD(&amp;sheldon_uvc_queue.irqqueue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbuffers; ++i) &#123;</span><br><span class="line">    sheldon_uvc_queue.buffer[i].buf.index = i;</span><br><span class="line">    sheldon_uvc_queue.buffer[i].buf.m.offset = i * bufsize;</span><br><span class="line">    sheldon_uvc_queue.buffer[i].buf.length = sheldon_uvc_format.fmt.pix.sizeimage;</span><br><span class="line">    sheldon_uvc_queue.buffer[i].buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    sheldon_uvc_queue.buffer[i].buf.sequence = <span class="number">0</span>;</span><br><span class="line">    sheldon_uvc_queue.buffer[i].buf.field = V4L2_FIELD_NONE;</span><br><span class="line">    sheldon_uvc_queue.buffer[i].buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">    sheldon_uvc_queue.buffer[i].buf.flags = <span class="number">0</span>;</span><br><span class="line">    sheldon_uvc_queue.buffer[i].state    = VIDEOBUF_IDLE; <span class="comment">//分配好后为空闲状态</span></span><br><span class="line">    init_waitqueue_head(&amp;sheldon_uvc_queue.buffer[i].wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sheldon_uvc_queue.mem = mem;</span><br><span class="line">sheldon_uvc_queue.count = nbuffers;</span><br><span class="line">sheldon_uvc_queue.buf_size = bufsize;</span><br><span class="line">ret = nbuffers;</span><br></pre></td></tr></table></figure>
<h4 id="vidioc-querybuf">vidioc_querybuf</h4>
<p>这段代码是处理<code>VIDIOC_QUERYBUF</code> ioctl请求的函数，用于查询有关特定缓冲区的状态和属性。</p>
<p>简单来说，就是查询我们指定的缓冲区，由于缓冲区已经被我们维护在全局变量的缓冲区队列里了，所以只需要指定要查询的index就可以找到，然后就是把这个缓冲区memcpy出来，对其进行一系列的检查和配置。</p>
<p><strong>主要逻辑</strong>：</p>
<ol>
<li>验证<code>v4l2_buf-&gt;index</code>是否超出了当前分配的缓冲区数量（<code>sheldon_uvc_queue.count</code>）。如果索引无效，则返回错误码<code>-EINVAL</code>。</li>
<li>复制缓冲区信息</li>
<li><strong>更新标志</strong>：根据缓冲区的使用情况更新<code>v4l2_buf-&gt;flags</code>。如果缓冲区当前被映射到某个用户空间地址（<code>vma_use_count</code>不为0），则设置<code>V4L2_BUF_FLAG_MAPPED</code>标志。</li>
<li><strong>更新缓冲区状态标志</strong>：根据缓冲区的当前状态，进一步更新<code>v4l2_buf-&gt;flags</code>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (v4l2_buf-&gt;index &gt;= sheldon_uvc_queue.count) &#123;</span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(v4l2_buf, &amp;sheldon_uvc_queue.buffer[v4l2_buf-&gt;index].buf, <span class="keyword">sizeof</span>(*v4l2_buf));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新flags, 如果缓冲区当前被映射到某个用户空间地址（vma_use_count不为0），则设置V4L2_BUF_FLAG_MAPPED标志。 */</span></span><br><span class="line"><span class="keyword">if</span> (sheldon_uvc_queue.buffer[v4l2_buf-&gt;index].vma_use_count)</span><br><span class="line">    v4l2_buf-&gt;flags |= V4L2_BUF_FLAG_MAPPED;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (sheldon_uvc_queue.buffer[v4l2_buf-&gt;index].state) &#123;</span><br><span class="line">    <span class="keyword">case</span> VIDEOBUF_ERROR:</span><br><span class="line">    <span class="keyword">case</span> VIDEOBUF_DONE:</span><br><span class="line">        v4l2_buf-&gt;flags |= V4L2_BUF_FLAG_DONE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIDEOBUF_QUEUED:</span><br><span class="line">    <span class="keyword">case</span> VIDEOBUF_ACTIVE:</span><br><span class="line">        v4l2_buf-&gt;flags |= V4L2_BUF_FLAG_QUEUED;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIDEOBUF_IDLE:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vidioc-qbuf">vidioc_qbuf</h4>
<p>这段代码实现了<code>VIDIOC_QBUF</code> ioctl请求的处理函数，作用是将一个缓冲区排入队列以供视频捕获使用</p>
<p>简单来说，主要就是检查状态，修改状态，然后把修改后的buffer放入队列。</p>
<p><strong>主要逻辑</strong></p>
<ol>
<li>检查传入的参数是否有误</li>
<li>修改状态</li>
<li><strong>放入队列</strong>：将缓冲区添加到两个队列中：mainqueue和irqqueue
<ul>
<li><code>mainqueue</code>供APP使用，当缓冲区没有数据时,放入mainqueue队列。当缓冲区有数据时, APP从mainqueue队列中取出。</li>
<li><code>irqqueue</code>是供产生数据使用，当采集到数据时,从irqqueue队列中取出第1个缓冲区,存入数据</li>
</ul>
</li>
</ol>
<h4 id="vidioc-dqbuf">vidioc_dqbuf</h4>
<p>这段代码是处理<code>VIDIOC_DQBUF</code> ioctl请求的函数，用于从视频设备的缓冲区队列中取出一个已经填充好数据的缓冲区。</p>
<p>简单来说，就是检查储存处理视频数据的队列是否为空，如果不为空，就用list_first_entry宏取出第一个缓冲区，然后修改状态，并将其队列删除。</p>
<p><strong>主要逻辑</strong></p>
<ol>
<li>检查mainqueue是否为空，如果不为空，用获取<code>mainqueue</code>队列中的第一个缓冲区。这个宏利用缓冲区的<code>stream</code>链表节点来找到缓冲区结构体。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">buf = list_first_entry(&amp;sheldon_uvc_queue.mainqueue, <span class="keyword">struct</span> sheldon_uvc_buffer, stream);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>检查缓冲区的状态，如果缓冲区状态为<code>VIDEOBUF_DONE</code>，表示缓冲区已经被成功填充数据，缓冲区的状态将被设置为<code>VIDEOBUF_IDLE</code>，表示它现在是空闲的，可以再次被排队使用。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (buf-&gt;state) &#123;</span><br><span class="line">    <span class="keyword">case</span> VIDEOBUF_ERROR:</span><br><span class="line">        ret = -EIO;</span><br><span class="line">    <span class="keyword">case</span> VIDEOBUF_DONE:</span><br><span class="line">        buf-&gt;state = VIDEOBUF_IDLE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> VIDEOBUF_IDLE:</span><br><span class="line">    <span class="keyword">case</span> VIDEOBUF_QUEUED:</span><br><span class="line">    <span class="keyword">case</span> VIDEOBUF_ACTIVE:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>从队列中删除缓冲区</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_del(&amp;buf-&gt;stream);</span><br></pre></td></tr></table></figure>
<h4 id="vidioc-streamon">vidioc_streamon</h4>
<p>先跳过其他的，看看下面几个</p>
<h5 id="1-usb-set-interface">1. usb_set_interface</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">usb_set_interface(sheldon_uvc_udev, sheldon_uvc_streaming_intf, sheldon_uvc_streaming_bAlternateSetting);</span><br></pre></td></tr></table></figure>
<p>这行代码在USB视频类（UVC）设备驱动程序中的作用是切换USB设备的当前接口到一个指定的替代设置。</p>
<h5 id="2-分配设置URB">2. 分配设置URB</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sheldon_uvc_alloc_init_urbs</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    u16 psize;</span><br><span class="line">    u32 size;</span><br><span class="line">    <span class="type">int</span> npackets;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">urb</span> *<span class="title">urb</span>;</span></span><br><span class="line"></span><br><span class="line">    psize = wMaxPacketSize; <span class="comment">/* 实时传输端点一次能传输的最大字节数 */</span></span><br><span class="line">    size  = sheldon_uvc_params.dwMaxVideoFrameSize;  <span class="comment">/* 一帧数据的最大长度 */</span></span><br><span class="line">    npackets = DIV_ROUND_UP(size, psize); </span><br><span class="line">    <span class="keyword">if</span> (npackets &gt; <span class="number">32</span>)</span><br><span class="line">        npackets = <span class="number">32</span>;</span><br></pre></td></tr></table></figure>
<p>npackets是数据包的数量，用一帧数据的最大长度除以端点一次能传输的最大字节数，并向上取整得到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">size = sheldon_uvc_queue.urb_size = psize * npackets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sheldon_UVC_URBS; ++i) &#123;</span><br><span class="line">    <span class="comment">/* 1. 分配usb_buffers */</span></span><br><span class="line"></span><br><span class="line">    sheldon_uvc_queue.urb_buffer[i] = usb_buffer_alloc(</span><br><span class="line">        sheldon_uvc_udev, size,</span><br><span class="line">        GFP_KERNEL | __GFP_NOWARN, &amp;sheldon_uvc_queue.urb_dma[i]); <span class="comment">//sheldon_uvc_queue.urb_dma[i]存放分配的物理地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 分配urb */</span></span><br><span class="line">    sheldon_uvc_queue.urb[i] = usb_alloc_urb(npackets, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sheldon_uvc_queue.urb_buffer[i] || !sheldon_uvc_queue.urb[i])</span><br><span class="line">    &#123;</span><br><span class="line">        sheldon_uvc_uninit_urbs();</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里分配了两个地方，一个是urb_buffer，一个是urb，在usb_alloc_urb中，npackets表示使用iso传输，并且传输的数据包的数量是npackets。这里的urb_buffer会在urb里面用到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 3. 设置urb */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sheldon_UVC_URBS; ++i) &#123;</span><br><span class="line">        urb = sheldon_uvc_queue.urb[i];</span><br><span class="line"></span><br><span class="line">        urb-&gt;dev = sheldon_uvc_udev;</span><br><span class="line">        urb-&gt;context = <span class="literal">NULL</span>;</span><br><span class="line">        urb-&gt;pipe = usb_rcvisocpipe(sheldon_uvc_udev,sheldon_uvc_bEndpointAddress);</span><br><span class="line">        urb-&gt;transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;</span><br><span class="line">        urb-&gt;interval = <span class="number">1</span>;</span><br><span class="line">        urb-&gt;transfer_buffer = sheldon_uvc_queue.urb_buffer[i]; <span class="comment">//分配的urb buffer</span></span><br><span class="line">        urb-&gt;transfer_dma = sheldon_uvc_queue.urb_dma[i]; <span class="comment">//分配的urb 物理地址</span></span><br><span class="line">        urb-&gt;complete = sheldon_uvc_video_complete; <span class="comment">//zwming：回调函数，一旦urb处理完成（无论成功与否），此函数被调用</span></span><br><span class="line">        urb-&gt;number_of_packets = npackets; <span class="comment">//要传输的数据次数</span></span><br><span class="line">        urb-&gt;transfer_buffer_length = size; <span class="comment">//总共的数据量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; npackets; ++j) &#123;</span><br><span class="line">            urb-&gt;iso_frame_desc[j].offset = j * psize;  <span class="comment">//存放每次传输的数据</span></span><br><span class="line">            urb-&gt;iso_frame_desc[j].length = psize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是对urb里面的信息进行填充，然后进行提交，（好像不在这个地方提交），urb就是需要填充各种信息来实现usb的数据传输，比较重要的是urb-&gt;dev字段，维护要传输的usb设备，urb-&gt;pipe，维护传输的方向和端点地址，为什么有端点是因为usb实际上有很多个端点，每个端点负责不同的事情。usb-&gt;complete是urb处理完成后的回调函数，这个回调函数待会儿会仔细看。urb-&gt;<code>iso_frame_desc</code>数组用于描述每个ISO包的大小和偏移，在回调函数里会用到。现在来看看这个回调函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sheldon_uvc_video_complete</span><span class="params">(<span class="keyword">struct</span> urb *urb)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;sheldon_uvc_queue.irqqueue)) <span class="comment">//如果队列不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        buf = list_first_entry(&amp;sheldon_uvc_queue.irqqueue, <span class="keyword">struct</span> sheldon_uvc_buffer, irq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; urb-&gt;number_of_packets; ++i) &#123;</span><br><span class="line">         <span class="keyword">if</span> (urb-&gt;iso_frame_desc[i].status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             printk(<span class="string">&quot;USB isochronous frame lost (%d).\n&quot;</span>, urb-&gt;iso_frame_desc[i].status);</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>irqqueue维护的是采集到的数据，这里应该是采集到一帧画面了所以要取出一个irqqueue缓存来放入那一帧画面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">src  = urb-&gt;transfer_buffer + urb-&gt;iso_frame_desc[i].offset; <span class="comment">//源</span></span><br><span class="line"></span><br><span class="line">dest = sheldon_uvc_queue.mem + buf-&gt;buf.m.offset + buf-&gt;buf.bytesused; <span class="comment">//目的</span></span><br><span class="line"></span><br><span class="line">len = urb-&gt;iso_frame_desc[i].actual_length; <span class="comment">//整个数据长度</span></span><br></pre></td></tr></table></figure>
<p>我不懂为什么这样就可以取出源和目的的地址，但姑且就不去理解吧，反正就是要把src的数据放到dest里面去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 判断数据是否有效 */</span></span><br><span class="line"><span class="comment">/* URB数据含义:</span></span><br><span class="line"><span class="comment">* data[0] : 头部长度</span></span><br><span class="line"><span class="comment">* data[1] : 错误状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">2</span> || src[<span class="number">0</span>] &lt; <span class="number">2</span> || src[<span class="number">0</span>] &gt; len)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip payloads marked with the error bit (&quot;error frames&quot;). */</span></span><br><span class="line"><span class="keyword">if</span> (src[<span class="number">1</span>] &amp; UVC_STREAM_ERR) &#123;</span><br><span class="line">    printk(<span class="string">&quot;Dropping payload (error bit set).\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 除去头部后的数据长度 */</span></span><br><span class="line">len -= src[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 缓冲区最多还能存多少数据 */</span></span><br><span class="line">maxlen = buf-&gt;buf.length - buf-&gt;buf.bytesused;</span><br><span class="line">nbytes = min(len, maxlen);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复制数据 */</span></span><br><span class="line"><span class="built_in">memcpy</span>(dest, src + src[<span class="number">0</span>], nbytes);</span><br><span class="line">buf-&gt;buf.bytesused += nbytes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断一帧数据是否已经全部接收到 */</span></span><br><span class="line"><span class="keyword">if</span> (len &gt; maxlen) &#123;</span><br><span class="line">    buf-&gt;state = VIDEOBUF_DONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一块主要做的是复制有效数据到目标缓冲区里，但也不是很懂。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Mark the buffer as done if the EOF marker is set. */</span></span><br><span class="line"><span class="keyword">if</span> (src[<span class="number">1</span>] &amp; UVC_STREAM_EOF &amp;&amp; buf-&gt;buf.bytesused != <span class="number">0</span>) &#123;</span><br><span class="line">    printk(<span class="string">&quot;Frame complete (EOF found).\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        printk(<span class="string">&quot;EOF in empty payload.\n&quot;</span>);</span><br><span class="line">    buf-&gt;state = VIDEOBUF_DONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果遇到帧结束（EOF）标志，标记缓冲区状态为<code>VIDEOBUF_DONE</code>，表示一帧视频数据已完全接收。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 当接收完一帧数据,</span></span><br><span class="line"><span class="comment">* 从irqqueue中删除这个缓冲区</span></span><br><span class="line"><span class="comment">* 唤醒等待数据的进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (buf-&gt;state == VIDEOBUF_DONE ||</span><br><span class="line">    buf-&gt;state == VIDEOBUF_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">    list_del(&amp;buf-&gt;irq);</span><br><span class="line">    wake_up(&amp;buf-&gt;wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 提交URB以接收数据</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sheldon_UVC_URBS; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((ret = usb_submit_urb(sheldon_uvc_queue.urb[i], GFP_KERNEL)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to submit URB %u (%d).\n&quot;</span>, i, ret);</span><br><span class="line">        sheldon_uvc_uninit_urbs();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步感觉很好理解了，第二步配置完urb后，现在就submit上去，然后有事件发生，就触发回调函数执行，然后就是执行上面描述的事情了。</p>
<h4 id="vidioc-streamoff">vidioc_streamoff</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sheldonUV_vidioc_streamoff</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">void</span> *priv, <span class="keyword">enum</span> v4l2_buf_type t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">urb</span> *<span class="title">urb</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. kill URB */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sheldon_UVC_URBS; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((urb = sheldon_uvc_queue.urb[i]) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        usb_kill_urb(urb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. free URB */</span></span><br><span class="line">    sheldon_uvc_uninit_urbs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 设置VideoStreaming Interface为setting 0 */</span></span><br><span class="line">    usb_set_interface(sheldon_uvc_udev, sheldon_uvc_streaming_intf, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数现在感觉很好理解了，无非就是销毁urb，然后把接口换回去，但我还是不懂这个接口为什么要换来换去。</p>
<hr>
<p>异步视频数据传输体现在哪里？</p>
<p>因为我们配置完urb请求块之后， 就把urb submit上去。一旦urb被提交，程序可以立即执行其他任务。这个urb就交给usb核心来处理了，usb核心会在数据传输完成后，调用关联的回调函数。于是我们的程序就可以执行其他的任务，譬如继续接收下一批数据。</p>
<blockquote>
<p>USB核心会根据URB的指示与USB设备进行数据传输，一旦传输完成（或遇到错误），USB核心会自动调用回调函数。所以异步数据传输就体现在这里，urb数据传输由usb核心来完成，程序负责将获得到的urb块里的数据复制到视频帧缓存中，并供应用程序使用。</p>
</blockquote>
<p>非阻塞io体现在哪里？</p>
<blockquote>
<p>在video_device中用了fops，里面维护了一个poll函数，在这个poll函数里面，它取出了mainqueue里面非空的一个buffer，然后用poll_wait把这个任务添加到等待队列里，这样进程就允许继续执行其他代码，等到有wake信号的时候，才会继续执行poll后面的代码。所以它是非阻塞的</p>
</blockquote>
<p>动态分配和回收视频帧缓冲区在哪里体现？</p>
<blockquote>
<p>在urb完成回调函数中，驱动程序会将接收到的视频数据复制到之前分配的缓冲区中，这个过程涉及到检查urb的状态，处理接收到的数据包，将数据从usb传输缓冲区复制到视频帧缓冲区。缓冲区的回收体现在，当数据被上层提取后，相应的缓冲区会被回收以供再次使用。</p>
</blockquote>
<p>为什么uvc_queue明明分配了buffer[32]，但还是要mainqueue来维护队列，并且用list_add_tail 这种内核定义的函数？</p>
<blockquote>
<p>uvc_queue确实是用<code>struct sheldon_uvc_buffer buffer[32]</code>数组预分配了一块缓冲区，但不知道这块缓冲区的用途是什么，所以要用mainqueue队列和irqqueue队列来维护这32个缓冲区，mainqueue用来供应用层使用，主要用来放没有数据的缓冲区，当应用层需要缓冲区来存放数据时，就从这里拿。irqqueue用来放有数据的缓冲区，当采集到数据后，要对数据进行处理，就从这里拿。</p>
<p>所以，由于预分配的只有32块，这两个队列最多也只能存32个节点。</p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">郑伟铭</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://solicitousmonkey.github.io/2024/03/21/UVC驱动/">https://solicitousmonkey.github.io/2024/03/21/UVC驱动/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://solicitousmonkey.github.io">zwm's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/uvc%E9%A9%B1%E5%8A%A8/">uvc驱动</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/03/27/%E9%A2%91%E7%B9%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%94%B9%E8%BF%9B/"><i class="fa fa-chevron-left">  </i><span>频繁创建线程的缺点以及如何改进</span></a></div><div class="next-post pull-right"><a href="/2024/02/22/TCP%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E6%AD%A5%E9%AA%A4/"><span>TCP创建套接字的步骤</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://solicitousmonkey.github.io/2024/03/21/UVC%E9%A9%B1%E5%8A%A8/';
  this.page.identifier = '2024/03/21/UVC驱动/';
  this.page.title = 'UVC驱动';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'zwming-cn' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://zwming-cn.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2023 - 2024 By 郑伟铭</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>