{"posts":[{"title":"简单的led驱动程序","text":"最简单的led驱动程序 驱动程序： #include&lt;linux/kernel.h&gt;#include&lt;linux/module.h&gt;#include&lt;linux/slab.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/poll.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/wait.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;asm/io.h&gt;static int major;static struct class *led_class;/* registers */// IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3地址：0x02290000 + 0x14static volatile unsigned *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3; // 不可以使用物理地址来访问寄存器，一定要用虚拟地址// GPIO5_GDIR地址：0x020AC004static volatile unsigned *GPIO5_GDIR;// GPIO5_DR地址：0x020AC000; 用来设置高低电平static volatile unsigned *GPIO5_DR;static ssize_t led_write(struct file *filp, const char __user *buf, size_t count, loff_t *ppos){ // 从app获得数据，设置gpio注册器的值 char val; copy_from_user(&amp;val, buf, 1); if (val) { *GPIO5_DR &amp;= ~(1&lt;&lt;3); } else { *GPIO5_DR |= ~(1&lt;&lt;3); } return 1;}static ssize_t led_open(struct inode *inode, struct file *filp){ /* enable gpio5 * configure gpio5_io3 as gpio * configure gpio5_io3 as output */ *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 &amp;= ~0xf; // 先清空 *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 |= ~0x5; // 0x5 就是 101 *GPIO5_GDIR |= (1&lt;&lt;3); // 因为该寄存器的第三位设为1是输出}static struct file_operation led_fops = { .owner = THIS_MODULE, .open = led_open(), .write = led_write(),};/* 1. 入口函数 */// static 表示函数仅在当前文件内可见，不能被其他文件访问。// 这对于内核模块编程很重要，因为内核模块通常由多个文件组成，需要控制函数的可见性。static int __init led_init(void) // 这只是一个普通的函数，需要用module_init来使其称为入口函数{ printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__) major = register_chrdev(0, &quot;zwm&quot;, &amp;led_fops); /* ioremap */ // IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3地址：0x02290000 + 0x14 IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = ioremap(0x02290000 + 0x14, 4); // GPIO5_GDIR地址：0x020AC004 GPIO5_GDIR = ioremap(0x020AC004, 4); // GPIO5_DR地址：0x020AC000; 用来设置高低电平 GPIO5_DR = ioremap(0x020AC000, 4); led_class = class_create(THIS_MODULE, &quot;myled&quot;); // 该函数用于提供一些辅助信息，系统使用这些信息创建设备节点 device_create(led_class, NULL, MKDEV(major, 0), NULL, &quot;myled&quot;); // 系统会创建 /dev/myled 这一设备节点 return 0;}static void __exit led_exit(void){ iounmap(IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3); iounmap(GPIO5_GDIR); iounmap(GPIO5_DR); device_destory(led_class, MKDEV(major, 0)); // class_destory(led_class); unregister_chrdev(major, &quot;zwm&quot;);}module_init(led_init); // module_init 是一个宏module_exit(led_init); // 同上MODULE_LICENSE(&quot;GPL&quot;); 测试程序： #include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;// ledtest /dev/myled on// ledtest /dev/myled offint main(int argc, char **argv){ int fd; char status = 0; if (argc != 3) { // 打印用法 printf(&quot;Usage: %s &lt;dev&gt; &lt;on/off&gt;\\n&quot;, argv[0]); return -1; } // open fd = open(argv[1], O_RDWR); if (fd &lt; 0) { // fail return -1; } // write if (strcmp(argv[2], &quot;on&quot;) == 0) { status = 1; } write(fd, &amp;status, 1); return 0;}","link":"/2023/11/07/%E7%AE%80%E5%8D%95%E7%9A%84led%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"},{"title":"奇奇怪怪的碎碎念","text":"2023年11月份的碎碎念 11月的第一个星期 emotion：😭😭😭😭😭 🎸起因：新裤子北海怪兽演唱，本来没打算抢票的我，总觉得都开到家门口了，不抢怪可惜的。 起初不打算抢票的原因： 感觉新裤子越来越流行化了，觉得朋克太土了。 总觉得开演唱会太不像摇滚乐做的事儿了，摇滚乐就应该好好呆在livehouse， 改变心意的原因： 前一天晚上看了月夏最后一集的演唱会，朋克虽然土，但真的好容易让人回荡起被琐碎日子磨平的情绪，不用思考，没有晦涩的歌词，没有刻意制造的深刻，没有对社会的苦大仇深与抨击。我在这总是能感到裸露的情绪，为自己还能感受世界而庆幸。 第二个原因就是距离真的太近了，离学校只有不到2km的距离。 🌸经过：下午四点突然收到新裤子演唱会放票的信息，点进去一看发现280、580、780、980的票都有，我当机立断就想起前一天晚上想到如果有票的话叫上FL哥，但是之前根本没录入他们的个人身份信息，买票的时候就需要重新录入，一通下来本来可以抢到280票的我，硬生生因为录入他们的信息花了太多时间，错过280的票。此时已经很冲动了，想要去看演唱会的心情达到峰值，简单询问了一下就买了580的票乘4！！！！ 🌰结果：太贵了！！太亏了！！还不能退票！！退票要收20%的手续费！！搞的FL哥和章鱼哥莫名支出了一大笔钱，关键是原本是不想看的，就算想看也是最便宜的票，一下子就比原计划多花了三百块！！！而且其实大家都互相不认识，感觉会尴尬。 而且FL哥感觉没有很想去，这波是擅自给别人做决定了，本来是打算买280的票然后就请他看的，因为冲动买票的行为导致也请不起了。 😭 导致：emo了一下午，觉得自己做事情太冲动太冲动，太不成熟，以此为鉴，得出一些结论，希望以后能减少此类事情的发生： 🌏心得： 提前确定好买票人，不要临时更改。如果有临时想叫的人，先管好已经定下来的，再去问别人。 提前录入买票人信息和取票地址。 不一定要一起买，不用为了连座特地一起买票，没有抢到票一切都是徒劳的。 只买最便宜一档的票！没有了就不买！因为总会等到有人出的！！ 面对突如其来的票，先管自己的，再去管别人的，不带来不必要的麻烦。 将该抢票心得映射到其他的事情上： 不要在心急的时候做决定！不要被突如其来的计划改变乱了阵脚！如果实在计划有变，考虑此事事关自己还是事关他人， 如若事关他人，则不要轻易改变计划，别人不一定能接受突然的改变，并且计划的改变通常以为着要付出代价，别人不一定能够接受这样的代价。 如果事关自己，可以争取改变，毕竟自己能够承担自己做的事情带来的代价。 这次就算了，好好享受这一场演唱会，想太多也没有用，期待演出捏 最后附上新裤子的一首歌，歌名与今日感受十分贴切，🎧 ----&gt; 荒废的一天 END/","link":"/2023/11/01/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"title":"驱动开发入门","text":"编写驱动步骤 确定主设备号 定义自己的file_operator结构体 实现对应的open\\read\\write等函数，填入file_operator结构体 把file_operator结构体告诉内核：注册驱动程序 入口函数：安装驱动程序时就会调用该入口函数 出口函数：卸载驱动程序时，就会调用该出口函数 其他完善：提供设备信息，自动创建设备节点 编写一个简单的hello驱动（不涉及硬件） #include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/miscdevice.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/major.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/seq_file.h&gt;#include &lt;linux/stat.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/tty.h&gt;#include &lt;linux/kmod.h&gt;#include &lt;linux/gfp.h&gt;/* 1. 确定主设备号 */static int major = 0;static char kernel_buf[1024];static struct class *hello_class;#define MIN(a, b) (a&lt;b?a : b)/* 3. 实现对应的open、read、write函数，填入file_operation结构体 */ssize_t hello_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset){ printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); copy_to_user(buf, kernel_buf, MIN(1024, size)); return MIN(1024, size);}ssize_t hello_drv_write (struct file *file, const char __user *buf, size_t size, loff_t *offset){ printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); copy_from_user(kernel_buf, buf, MIN(1024, size)); return MIN(1024, size);}int hello_drv_open (struct inode *node, struct file *file){ printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); return 0;}int hello_drv_close (struct inode *node, struct file *file){ printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__);}/* 2. 定义自己的file_operation结构体 */static struct file_operation hello_drv = { .owner = THIS_MODULW, .open = hello_drv_open, .read = hello_drv_read, .write = hello_drv_write, .release = hello_drv_close,};/* 4. 注册驱动程序，把file_operation结构体告诉内核 *//* 5. 入口函数 */static int __init hello_init(void){ int err; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); major = register_chrdev(0, &quot;hello&quot;, &amp;hello_drv); hello_class = class_create(THIS_MODULE, &quot;hello_class&quot;); /* /dev/hello */ err = PTR_ERR(hello_class); if (IS_ERR(hello_class)) { printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); unregister_chrdev(major, &quot;hello&quot;); return -1; } device_create(hello_class, NULL, MKDEV(major, 0), NULL, &quot;hello&quot;); return 0;}/* 6. 出口函数 */static void __exit hello_exit (void){ printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); device_destory(hello_class, MKDEV(major, 0)); class_destory(hello_class); unregister_chrdev(major, &quot;hello&quot;);}/* 7. 其他完善：提供设备信息，自动创建节点 */module_init(hello_init);module_exit(hello_exit);MODULE_LICENSE(&quot;GPL&quot;); 其中： __FILE__ 是预处理器宏，用于表示当前源文件名。 __FUNCTION__ 是编译器宏，用于表示当前函数名。 __LINE__ 是预处理器宏，用于表示当前行号。 这些宏常用于调试，以了解代码的执行位置。 printk 是Linux内核中用于打印调试信息的函数，类似于C标准库中的 printf。 两种三极管 N是负极 GPIO 四个步骤: 使能 power/clock pin’mode可以是uart或gpio等等，因此要选择pin’mode 方向：读 or 写 数据：高电平 or 低电平","link":"/2023/10/26/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"驱动开发","slug":"驱动开发","link":"/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"本人的碎碎念","slug":"本人的碎碎念","link":"/tags/%E6%9C%AC%E4%BA%BA%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"categories":[],"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}