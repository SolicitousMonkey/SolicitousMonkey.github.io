<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="输入子系统の驱动框架"><meta name="keywords" content="驱动开发"><meta name="author" content="郑伟铭"><meta name="copyright" content="郑伟铭"><title>输入子系统の驱动框架 | zwm's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">1、前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">2、输入子系统层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%B1%82%EF%BC%9Ainput-handler"><span class="toc-number">2.1.</span> <span class="toc-text">2.1事件处理层：input_handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%A0%B8%E5%BF%83%E5%B1%82%EF%BC%9Ainput-handle"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 核心层：input_handle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E9%A9%B1%E5%8A%A8%E5%B1%82%EF%BC%9Aintut-dev"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 驱动层：intut_dev</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">3、关键数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-input-handler"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 input_handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-input-handle"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 input_handle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-input-dev"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 input_dev</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-input-dev%E3%80%81input-handler%E3%80%81input-handle%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 input_dev、input_handler、input_handle三者的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81input%E5%AD%90%E7%B3%BB%E7%BB%9F%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">4、input子系统驱动框架分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%80%8E%E4%B9%88%E6%B7%BB%E5%8A%A0input-dev"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 怎么添加input_dev</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-input-dev%E5%92%8Cinput-handler%E5%8C%B9%E9%85%8D%E5%90%8E%EF%BC%8Cconnec%E5%87%BD%E6%95%B0%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 input_dev和input_handler匹配后，connec函数做了什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81-input%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">5、 input子系统读数据流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-open%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87%E6%B5%81%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 open输入设备流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-read%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 read读取输入事件流程</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpg"></div><div class="author-info__name text-center">郑伟铭</div><div class="author-info__description text-center">研究方向：深度强化学习，需求响应优化；学习方向：驱动开发</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/SolicitousMonkey">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">35</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">zwm's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">输入子系统の驱动框架</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-11-23</time><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2023/11/23/%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E3%81%AE%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2023/11/23/输入子系统の驱动框架/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本文<strong>参考</strong>了CSDN博主「陈 洪 伟」的原创文章<br>
原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013171226/article/details/133985487">https://blog.csdn.net/u013171226/article/details/133985487</a></p>
<h3 id="1、前言">1、前言</h3>
<p>输入子系统提供了一种通用的机制，用于处理各种输入设备，如键盘、鼠标、触摸屏等。</p>
<p>换句话说，就是将大部分的输入设备抽象出一个公共层出来，方便应用层使用</p>
<hr>
<h3 id="2、输入子系统层次结构">2、输入子系统层次结构</h3>
<p><img src="image-20231216151859600.png" alt="image-20231216151859600"></p>
<h4 id="2-1事件处理层：input-handler">2.1事件处理层：input_handler</h4>
<ol>
<li>事情处理层主要是负责将输入事件上报到应用程序；对于已经向内核输入子系统注册的输入设备，在sysfs中创建设备节点，应用程序通过操作设备节点来获取输入事件。</li>
<li>事件处理层将输入事件划分为几大类，比如：通用事件(event)、鼠标事件(mouse)、摇杆事件(js)等等，每个输入类设备在注册时需要指定自己属于哪个类；</li>
<li>通用事件是能和任何输入设备匹配上的，意味着只要注册一个输入类设备就会sysfs就会创建对应的<code>/dev/input/eventn</code>设备节点；</li>
</ol>
<h4 id="2-2-核心层：input-handle">2.2 核心层：input_handle</h4>
<p>承上启下。为设备驱动层提供了规范和接口；通知事件处理层对事件进行处理；事件处理层和设备驱动层都必须先向核心层注册，然后才能工作；</p>
<ul>
<li>
<ol>
<li>申请主设备号</li>
<li>提供input_register_device跟input_register_handler函数分别用于注册device跟handler;</li>
<li>提供input_register_handle函数用于注册一个事件处理，代表一个成功配对的input_dev和input_handler;</li>
</ol>
</li>
</ul>
<h4 id="2-3-驱动层：intut-dev">2.3 驱动层：intut_dev</h4>
<p>把硬件产生的事件转换为核心层定义的规范提交给事件处理层。</p>
<hr>
<h3 id="3、关键数据结构">3、关键数据结构</h3>
<h4 id="3-1-input-handler">3.1 input_handler</h4>
<ul>
<li>即<strong>事件处理驱动</strong>，在内核启动过程中会向核心层注册handler；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">	<span class="type">void</span> *private; <span class="comment">//由具体的事件处理程序指定的私有数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//用于处理送到事件处理层的事件，该方法由核心层调用，调用时已经禁止了中断，</span></span><br><span class="line">	<span class="comment">//并获得dev-&gt;event lock ，因此不能喔珉</span></span><br><span class="line">	<span class="type">void</span> (*event)(<span class="keyword">struct</span> input_handle *handle, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value);</span><br><span class="line">	</span><br><span class="line">	<span class="type">bool</span> (*filter)(<span class="keyword">struct</span> input_handle *handle, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value);</span><br><span class="line">	<span class="type">bool</span> (*match)(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//在事件处理程序关联到一个输入设备时调用</span></span><br><span class="line">	<span class="type">int</span> (*connect)(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev, <span class="type">const</span> <span class="keyword">struct</span> input_device_id *id);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//在事件处理程序脱离与之关联的输入设备时调</span></span><br><span class="line">	<span class="type">void</span> (*disconnect)(<span class="keyword">struct</span> input_handle *handle);</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span> <span class="comment">//该事件处理驱动的文件操作集合</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//输入设备 ID衰，事件处理驱动通过这个成员来匹配它能处理的设备</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">h_list</span>;</span>	<span class="comment">//该事件处理程序关联的输入句柄列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">node</span>;</span>	<span class="comment">//所有有事件处理驱动都会通过该成员连接到 input_handler_list链表上</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-input-handle">3.2 input_handle</h4>
<ul>
<li><code>struct handle</code>连接了输入设备 (<code>input_dev</code>) 和事件处理驱动(<code>input_handler</code>)。有了handle之后，设备上报输入事件时才知道该往哪些事件处理驱动上报；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *private; <span class="comment">//由事件处理程序指定的私有数据</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> open;	<span class="comment">//记录句柄打开的次数 </span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;	<span class="comment">//处理程序创建该句柄时，指定的句柄名称＊</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span>	<span class="comment">//该句柄关联的输入设备</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span> <span class="comment">//句柄关联的事件处理程序</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">d_node</span>;</span>	<span class="comment">// 维护 dev 链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">h_node</span>;</span>	<span class="comment">// 维护 handle 链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-input-dev">3.3 input_dev</h4>
<ul>
<li>每个输入设备都有一个<code>input_dev</code>，<strong>用来抽象一个输入设备</strong>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;	<span class="comment">//设备名称</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *phys;	<span class="comment">//设备在系统中的物理路径</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *uniq;	<span class="comment">//设备唯一识别符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span>	<span class="comment">//设备工D，包含总线ID(PCI 、 USB)、厂商工D,与 input handler 匹配的时会用到</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)];	<span class="comment">//设备支持的事件类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">h_list</span>;</span>	<span class="comment">// 维护与该设备相关的 handle</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">node</span>;</span>	<span class="comment">// 挂接到input_dev_list链表上</span></span><br><span class="line">	...    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-input-dev、input-handler、input-handle三者的关系">3.4 input_dev、input_handler、input_handle三者的关系</h4>
<ol>
<li>input_handle结构体是用于记录匹配上的输入设备和事件处理驱动的，当设备驱动和事件处理驱动匹配上时就会新建一个handle并向核心层注册；</li>
<li>input_dev结构体中有h_list链表，里面记录的是设备对应的handle结构体</li>
<li>input_handler结构体中有h_list链表，里面记录的是设备对应的handle结构体；</li>
<li>handle结构体里的d_node是记录匹配上的input_dev结构体，h_node是记录的handler结构体；</li>
<li>如果知道handle结构体，可以通过d_node链表找到对应的input_dev结构体，通过h_node链表找到对应的handler结构体；</li>
<li>如果知道input_dev结构体，可以通过h_list链表找到handle结构体，再通过handle结构体的h_node链表找到匹配的handler结构体；</li>
<li>如果知道handler结构体，可以通过h_list链表找到handle结构体，再通过handle结构体的d_node链表找到匹配的input_dev结构体；</li>
</ol>
<blockquote>
<p>总结：<strong>三个结构体通过链表互相关联，只要知道其中一个就能通过链表找到另外两个</strong>；</p>
</blockquote>
<hr>
<h3 id="4、input子系统驱动框架分析">4、input子系统驱动框架分析</h3>
<p><img src="b4ed96f48c9142b8ab4a07c06dd0d6fe-17027142639248.png" alt="img"></p>
<p>如上图所示为输入子系统的设备层，核心层和处理层之间的关系，当我们用input_register_handler 函数添加handler的时候，会将其添加到input.c里面的一个链表中，同样当我们用input_register_device添加input_dev的时候，会将其添加到input.c的input_dev链表中，然后无论是我们添加handler还是添加device，内核都会对两者进行match，当发现某个device和handler相匹配的时候，就会调用handler里面的connect函数，然后再connect函数里面去申请input_handle结构体，这个input_handle结构体里面保存着匹配的input_handler和input_dev。</p>
<h4 id="4-1-怎么添加input-dev">4.1 怎么添加input_dev</h4>
<p>接下来将分别看一下我们怎么添加input_dev也就是上图中的左下角的input_dev是怎么被添加上的，然后再看一下右边connect函数内部的细节。</p>
<p><img src="1bfc2a9fe8d24c16ae8a7aaa288ec607.png" alt="img"></p>
<p>上图是以内核中的按键输入驱动为例，看一下是怎么添加input_dev的，从左边可以看到，首先我们编写设备树文件，然后设备树文件会被解析成platform_device，然后利用函数of_device_add添加到platform_bus_type的设备链表中，然后我们还会编写一个platform_driver驱动结构体，然后利用platform_driver_register函数将驱动注册内核中，无论我们添加驱动还是添加设备，内核都会去对设备和驱动进行匹配，匹配成功后就会调用驱动结构体里面的probe函数，也就是上图中的gpio_keys_probe函数，然后在probe函数中ongoing会申请input_dev结构体，并且利用input_register_device函数将设备注册到input系统的设备链表中。<br>
<img src="939a5edf69694f1dae11c834560af3b5.png" alt="img"></p>
<p>上图是以内核中的I2C接口的触摸屏驱动为例，看一下怎么添加input_dev的，这个图和前面的按键那个图类似，注意区别就是，对于i2c设备来说，它是挂载i2c_bus_type上面的不是platform_bus上的，其他的地方是类似的，就不再赘述了。</p>
<p>这里需要补充的一点是在connect函数中还有一个gtp_request_irq(ts);函数，这里是申请中断的，然后进一步调用了ret = request_threaded_irq(ts-&gt;client-&gt;irq, NULL,gtp_irq_handler,ts-&gt;pdata-&gt;irq_flags | IRQF_ONESHOT,ts-&gt;client-&gt;name,ts);函数，这里设置了中断处理函数是gtp_irq_handler，在gtp_irq_handler函数里面就是真正读取触摸屏数据的最底层的硬件函数了，里面就是调用i2c_transfer函数读取数据的了。</p>
<h4 id="4-2-input-dev和input-handler匹配后，connec函数做了什么">4.2 input_dev和input_handler匹配后，connec函数做了什么</h4>
<p><img src="45b5f8f7613948718dd6a2b153515055.png" alt="img"></p>
<p>前面看了怎么把input_dev添加到内核中，接下来看一下当input_dev和input_handler匹配后调用connect函数内部的细节，上图就是connect函数内部细节流程，</p>
<p>在connect函数里面我们可以猜一下，无非就是分配、设置、注册结构体，具体看一下里面，首先是申请了一个evdev结构体，然后我们可以看到这个evdev结构体里面又包含了input_handle结构体，然后这个input_handle结构体里面有两个重要成员就是input_dev和input_handler,这两个就是用来保存匹配的input_dev和input_handler的；</p>
<p>再往下可以看到list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);和list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);，这两个函数的意思就是把handle又分别保存到了input_handler和input_dev的链表中了。</p>
<p>再往下就是注册字符设备驱动程序，其中包含一个file_operations结构体，那么当应用程序调用open/read/write函数的时候就会调用这里的file_ops结构体里面的函数。</p>
<h3 id="5、-input子系统读数据流程">5、 input子系统读数据流程</h3>
<p>接下来我们看一下读取input输入事件数据的流程，先看一下open的流程。</p>
<h4 id="5-1-open输入设备流程">5.1 open输入设备流程</h4>
<p><img src="c1537998752a4c6db369213b71a871d0.png" alt="img"></p>
<p>上图就是open打开输入设备的流程，当我们调用open函数时，进一步会调用evdev_fops结构体里面的evdev_open函数，这个函数里面首先申请一个client，这个client就对应着我们的用户程序，然后会将这个client和evdev进行绑定，也就是把用户和输入设备绑定了。</p>
<h4 id="5-2-read读取输入事件流程">5.2 read读取输入事件流程</h4>
<p><img src="78e67f593ca545669e4494695d883050.png" alt="img"></p>
<p>如上图所示是read流程，先从最上面开始看，当应用程序调用read函数时，进一步会调用到evdev_read函数，然后在evdev_read函数中，如果有数据那么直接读取，如果没有数据，那么休眠等待。</p>
<p>好了，接下来再从图的最下面往上看，前面说了没数据就休眠，然后过一会硬件输入设备被操作了或者被按下了，然后就会产生中断，这时候就会进入中断处理函数，然后就会利用处理函数gpio_keys_gpio_work_func进行处理，然后这个函数一层层看下去最终就是调用input_event上报输入事件。</p>
<p>然后input_event其实就是核心层了，然后看一下input_event函数做了什么，这个函数一层层调用最终是调用到了input_to_handler函数，这个函数的源码大体可以看到，如果input_handler定义了filter就用filter函数处理，如果定义了input_handler-&gt;events函数那就用events函数处理，这里就是用events处理的。</p>
<p>那么这时候就去看input_handler-&gt;events函数，这个函数里面利用__pass_event(client, &amp;event);把数据传给client,这个client是在open时候分配的。然后唤醒前面休眠的程序，这时候evdev_read函数就会被唤醒，然后读取输入事件。</p>
<p>至此，输入事件的read过程结束。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">郑伟铭</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://solicitousmonkey.github.io/2023/11/23/输入子系统の驱动框架/">https://solicitousmonkey.github.io/2023/11/23/输入子系统の驱动框架/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://solicitousmonkey.github.io">zwm's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/11/25/%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"><i class="fa fa-chevron-left">  </i><span>平台设备驱动模型</span></a></div><div class="next-post pull-right"><a href="/2023/11/21/Linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"><span>Linux字符设备驱动</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://solicitousmonkey.github.io/2023/11/23/%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E3%81%AE%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/';
  this.page.identifier = '2023/11/23/输入子系统の驱动框架/';
  this.page.title = '输入子系统の驱动框架';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'zwming-cn' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://zwming-cn.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2023 By 郑伟铭</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>