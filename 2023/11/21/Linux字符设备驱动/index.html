<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Linux字符设备驱动"><meta name="keywords" content="驱动开发"><meta name="author" content="郑伟铭"><meta name="copyright" content="郑伟铭"><title>Linux字符设备驱动 | zwm's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">1、前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">2、关键数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-cdev"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 cdev</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-file-operations"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 file_operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-dev-t"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 dev_t</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">3、字符设备驱动整体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 加载与卸载函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E8%AE%BE%E5%A4%87%E5%8F%B7%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 设备号管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-%E8%AE%BE%E5%A4%87%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 设备号的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-%E8%AE%BE%E5%A4%87%E5%8F%B7%E7%9A%84%E5%88%86%E9%85%8D"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 设备号的分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-%E8%AE%BE%E5%A4%87%E5%8F%B7%E7%9A%84%E6%B3%A8%E9%94%80"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 设备号的注销</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-4-%E8%AE%BE%E5%A4%87%E5%8F%B7%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4 设备号的获取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-4-%E9%80%9A%E7%94%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.5.</span> <span class="toc-text">3.2.4 通用代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 字符设备的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1、字符设备初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2、字符设备注册</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%B3%A8%E9%94%80"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3、字符设备注销</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 文件操作接口的实现</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpg"></div><div class="author-info__name text-center">郑伟铭</div><div class="author-info__description text-center">研究方向：深度强化学习，需求响应优化；学习方向：驱动开发</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/SolicitousMonkey">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">40</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">zwm's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Linux字符设备驱动</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-11-21</time><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2023/11/21/Linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2023/11/21/Linux字符设备驱动/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="1、前言">1、前言</h3>
<p>众所周知，<code>Linux</code>内核主要包括三种驱动模型，字符设备驱动，块设备驱动以及网络设备驱动。</p>
<p>其中，<code>Linux</code>字符设备驱动，可以说是<code>Linux</code>驱动开发中最常见的一种驱动模型。</p>
<hr>
<h3 id="2、关键数据结构">2、关键数据结构</h3>
<h4 id="2-1-cdev">2.1 cdev</h4>
<p>可以理解为<code>char device</code>，主要作用是<strong>用来抽象一个字符设备。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">dev_t</span> dev;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p><strong>核心成员及含义</strong>：</p>
<ul>
<li><code>kobj</code>：表示一个内核对象。</li>
<li><code>owner</code>：指向该模块的指针</li>
<li><code>ops</code>：指向文件操作的指针，包括<code>open</code>、<code>read</code>、<code>write</code>等操作接口</li>
<li><code>list</code>：用于将该设备加入到内核模块链表中</li>
<li><code>dev</code>：设备号，由主设备号和次设备号构成</li>
<li><code>count</code>：表示有多少个同类型设备，也间接表示设备号的范围</li>
<li><code>__randomize_layout</code>：一个编译器指令，用于随机化结构体的布局，以增加安全性。</li>
</ul>
<h4 id="2-2-file-operations">2.2 file_operations</h4>
<p><strong>主要作用</strong>：正如其名，主要用来描述文件操作的各种接口，<code>Linux</code>一切接文件的思想，内核想要操作哪个文件，都需要通过这些接口来实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">    <span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">    <span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">    <span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line">    <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">    <span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line">    <span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">              <span class="type">loff_t</span> len);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line">            <span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*clone_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *, <span class="type">loff_t</span>,</span><br><span class="line">            u64);</span><br><span class="line">    <span class="type">int</span> (*dedupe_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *, <span class="type">loff_t</span>,</span><br><span class="line">            u64);</span><br><span class="line">    <span class="type">int</span> (*fadvise)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p><strong>核心成员及含义</strong>：</p>
<ul>
<li><code>open</code>：打开文件的函数</li>
<li><code>read</code>：读取文件的函数。</li>
<li><code>write</code>：写入文件的函数。</li>
<li><code>release</code>：关闭文件的函数。</li>
<li><code>flush</code>：刷新文件的函数，通常在关闭文件时调用。</li>
<li><code>llseek</code>：改变文件读写指针位置的函数。</li>
<li><code>fsync</code>：将文件数据同步写入磁盘的函数。</li>
<li><code>poll</code>：询问文件是否可被非阻塞读写</li>
</ul>
<h4 id="2-3-dev-t">2.3 dev_t</h4>
<p><strong>主要作用</strong>：表示字符设备对应的设备号，其中包括主设备号和次设备号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u32 <span class="type">__kernel_dev_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">__kernel_dev_t</span>  <span class="type">dev_t</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3、字符设备驱动整体架构">3、字符设备驱动整体架构</h3>
<h4 id="3-1-加载与卸载函数">3.1 加载与卸载函数</h4>
<p>驱动首先实现的就是加载和卸载函数，也是驱动程序的入口函数。</p>
<p>我们一般这么定义驱动的加载卸载函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br></pre></td></tr></table></figure>
<p>这段代码就是实现一个通用驱动的加载与卸载，关于<code>module_init</code>和<code>module_exit</code>的实现机制，可以查看之前总结文章。</p>
<h4 id="3-2-设备号管理">3.2 设备号管理</h4>
<h5 id="3-2-1-设备号的概念">3.2.1 设备号的概念</h5>
<p>每一类字符设备都有一个唯一的设备号，其中设备号又分为主设备号和次设备号，那么这两个分别作用是什么呢？</p>
<ul>
<li>主设备号：用于标识设备的类型，</li>
<li>次设备号：用于区分同类型的不同设备</li>
</ul>
<h5 id="3-2-2-设备号的分配">3.2.2 设备号的分配</h5>
<p>设备号的分配方式有静态分配，动态分配：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态分配</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态分配</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>; </span><br></pre></td></tr></table></figure>
<p>也可以使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// major设为0时，就由内核动态分配，否则静态分配</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span>;</span><br></pre></td></tr></table></figure>
<p>在<code>Linux</code>中，我们可以通过<code>cat /proc/devices</code>命令，查看所有i登记的设备号列表。</p>
<h5 id="3-2-3-设备号的注销">3.2.3 设备号的注销</h5>
<p>设备号作为一种系统资源，当所对应的设备卸载时，当然也要将其所占用的设备号归还给系统。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注销也有不同的api，这里展示一种</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>major</code>：主设备号</li>
<li><code>name</code>：设备号名字</li>
</ul>
<h5 id="3-2-4-设备号的获取">3.2.4 设备号的获取</h5>
<p>设备号的管理很简单，在关键数据结构中，我们看到设备号的类型是<code>dev_t</code>，也就是<code>u32</code>类型表示的一个数值。</p>
<p>其中主设备号和次设备号的分界线，由<code>MINORBITS</code>宏定义指定：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINORBITS 20</span></span><br></pre></td></tr></table></figure>
<p>也就是主设备号占用高<code>12bit</code>，次设备号占用低<code>20bit</code></p>
<p>并且，内核还提供了相关<code>API</code>接口，来获取主设备号和次设备号，以及生成设备号的接口，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINORMASK ((1U &lt;&lt; MINORBITS) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR(dev) ((unsigned int) ((dev) &gt;&gt; MINORBITS))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINOR(dev) ((unsigned int) ((dev) &amp; MINORMASK))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKDEV(ma,mi) (((ma) &lt;&lt; MINORBITS) | (mi)) <span class="comment">// 用于将主设备号和次设备号组合成一个 dev_t 类型的设备号。</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上，通过移位操作，来实现主次设备号的获取。</p>
</blockquote>
<h5 id="3-2-4-通用代码实现">3.2.4 通用代码实现</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CUSTOM_DEVICE_NUM 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NUM 1</span></span><br><span class="line"><span class="meta">#device DEVICE_NAME <span class="string">&quot;XXXXXX&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> global_custom_major = CUSTOM_DEVICE_NUM;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dev_t</span> custom_device_number= MKDEV(global_custom_major, <span class="number">0</span>); <span class="comment">// custom device number</span></span><br><span class="line">    <span class="comment">/* device number register*/</span></span><br><span class="line">    <span class="keyword">if</span> (global_custom_major) &#123;</span><br><span class="line">        ret = register_chrdev_region(custom_device_number, DEVICE_NUM, DEVICE_NAME);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = alloc_chrdev_region(&amp;custom_device_number, <span class="number">0</span>, DEVICE_NUM, DEVICE_NAME);</span><br><span class="line">        global_custom_major = MAJOR(custom_device_number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_chrdev_region(MKDEV(global_mem_major, <span class="number">0</span>), DEVICE_NUM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br></pre></td></tr></table></figure>
<p>该函数实现了设备号的分配，如果主设备号为<code>0</code>，则采用动态配分的方式，否则采用静态分配的方式。</p>
<h4 id="3-3-字符设备的管理">3.3 字符设备的管理</h4>
<p>了解完设备号的管理之后，我们来看下字符设备是如何管理的。</p>
<h5 id="3-3-1、字符设备初始化">3.3.1、字符设备初始化</h5>
<p><strong>函数作用</strong>：初始化一个字符设备，并且将所对应的文件处理指针与字符设备绑定起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-2、字符设备注册">3.3.2、字符设备注册</h5>
<p><strong>函数作用</strong>：添加一个字符设备驱动到<code>Linux</code>系统中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">p：一个字符设备指针，指向待添加的字符设备对象; </span></span><br><span class="line"><span class="comment">dev：该字符设备所负责的第一个设备编号</span></span><br><span class="line"><span class="comment">count：该类型设备的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h5 id="3-3-3、字符设备注销">3.3.3、字符设备注销</h5>
<p><strong>函数作用</strong>：从系统中移除该字符设备驱动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重要！！！！！！！！！！！！！！！！</p>
<p>不要混淆<code>register_chrdev</code>、<code>cdev_init</code>、<code>cdev_add</code>、 <code>class_create</code>、<code>device_create</code>这几个函数！！</p>
<ul>
<li>
<p><code>register_chrdev</code>只是用来分配设备号资源。</p>
</li>
<li>
<p><code>cdev_init</code>、 <code>cdev_add</code>， <code>cdev_del</code> 都是为了将字符设备注册进内核，管理字符设备对象。</p>
</li>
<li>
<p><code> class_create</code>、<code>device_create </code>用于在 <code>/dev</code> 目录下创建设备节点，使得用户空间能够访问到已注册的字符设备。</p>
</li>
</ul>
<p><strong>也就是说我可以用<code>cdev_init</code> 和 <code>cdev_add</code> 将字符设备注册进内核，但是我在用户空间还是看不到这个设备，只有用了 <code>device_create</code> 才能看到</strong>。</p>
</blockquote>
<h4 id="3-4-文件操作接口的实现">3.4 文件操作接口的实现</h4>
<p>因为在<code>Linux</code>中，一切皆文件的思想，所以每一个字符设备，也都有一个文件节点来对应。</p>
<p>我们在初始化字符设备的时候，会将<code>struct file_operations</code>的对象与字符设备进行绑定，其作用是来处理该字符设备的<code>open</code>、<code>read</code>、<code>write</code>等操作。</p>
<p>我们要做的就是去实现我们需要的函数接口，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">global_mem_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .llseek = global_mem_llseek,</span><br><span class="line">    .read = global_mem_read,</span><br><span class="line">    .write = global_mem_write,</span><br><span class="line">    .unlocked_ioctl = global_mem_ioctl,</span><br><span class="line">    .open = global_mem_open,</span><br><span class="line">    .release = global_mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>至此，我们一个基本的字符设备驱动程序的框架就基本了然于胸了</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">郑伟铭</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://solicitousmonkey.github.io/2023/11/21/Linux字符设备驱动/">https://solicitousmonkey.github.io/2023/11/21/Linux字符设备驱动/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://solicitousmonkey.github.io">zwm's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/11/23/%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E3%81%AE%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/"><i class="fa fa-chevron-left">  </i><span>输入子系统の驱动框架</span></a></div><div class="next-post pull-right"><a href="/2023/11/20/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%92%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"><span>嵌入式交叉编译环境和工具的使用</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://solicitousmonkey.github.io/2023/11/21/Linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/';
  this.page.identifier = '2023/11/21/Linux字符设备驱动/';
  this.page.title = 'Linux字符设备驱动';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'zwming-cn' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://zwming-cn.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2023 - 2024 By 郑伟铭</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>