<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>malloc和calloc的区别</title>
      <link href="/2024/12/18/malloc%E5%92%8Ccalloc%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/12/18/malloc%E5%92%8Ccalloc%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="malloc">malloc</h3><p><code>malloc</code> 是 C 语言中用于动态分配内存的函数。它允许程序在运行时请求一定数量的字节的内存，而不需要在编译时知道具体的内存需求</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>size</code>：要分配的内存字节数。</p></li><li><p><code>malloc</code> 返回一个指向新分配内存块的指针。如果分配失败，则返回 <code>NULL</code>。</p></li></ul><h3 id="calloc">calloc</h3><p><code>calloc</code> 用于在内存中分配指定数量的<strong>连续</strong>块，并将它们的值<strong>初始化为零</strong>。这个函数通常用于分配数组或结构体等数据结构。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> num_elements, <span class="type">size_t</span> element_size)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>num_elements</code>：要分配的元素数量。</p></li><li><p><code>element_size</code>：每个元素的大小（以字节为单位）。</p></li><li><p><code>calloc</code> 返回一个指向分配内存块的指针。如果分配失败，则返回 <code>NULL</code>。</p></li></ul><h3 id="区别">区别</h3><ol><li><strong>初始化与未初始化</strong>：<ul><li><code>calloc</code> 在分配内存的同时将其初始化为零，而 <code>malloc</code> 分配的内存内容是未初始化的。</li></ul></li><li><strong>参数个数</strong>：<ul><li><code>malloc</code> 只接受一个参数，即要分配的字节数，而 <code>calloc</code> 接受两个参数，分别是元素数量和每个元素的大小。</li></ul></li><li><strong>性能</strong>：<ul><li>由于 <code>calloc</code> 在分配时初始化内存，可能会稍微慢于 <code>malloc</code>。如果不需要初始化，而只关注分配速度，<code>malloc</code> 可能更为适合。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USB</title>
      <link href="/2024/02/02/USB/"/>
      <url>/2024/02/02/USB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CAN</title>
      <link href="/2024/01/31/CAN/"/>
      <url>/2024/01/31/CAN/</url>
      
        <content type="html"><![CDATA[<h3 id="CAN（Controller-Area-Network）">CAN（Controller Area Network）</h3><p>CAN一种串行通信协议，它可以使用双绞线来传输信号，总线空闲时为隐形位。</p><p><strong>信号线</strong>：有两根，分别是 <code>CAN_H</code>，<code>CAN_L</code>。其中CAN_H和CAN_L线是以双绞形式缠绕，采用差分的方式来表示CAN信号（也就是说用两根线来表示一个信号）。</p><p>CAN信号，分为显性电平(dominant)和隐性电平(recessive)两种类型。其中显性电平规定为逻辑0，隐性电平则为逻辑1，如下图所示，</p><p><strong>显性电平</strong>：当CAN_H的电压为3.5v，CAN_L的电压为1.5v，两者电压差为2V，就规定CAN信号为显性电平，逻辑为0；</p><p><strong>隐形电平</strong>：当CAN_H和CAN_L的电压均为2.5v，两者电压差为0，就规定CAN信号为隐性电平；</p><p><img src="/image-20240131160007052.png" alt="image-20240131160007052"></p><p>电压差满足定义的一定范围，就可以认为是显性电平或者隐性电平，比如电压差在<strong>1.5-2.5v</strong>范围，都认为是显性电平。</p><p>CAN协议基于事件驱动模式，即当一个节点需要发送数据时，**它会将数据打包成一个帧（frame）并通过总线发送给其他节点。**每个节点都能够接收总线上发送的帧，同时也可以发送帧到总线上。所有节点都可以同时接收和发送数据，而且不需要任何中央控制器。</p><h3 id="CAN收发器">CAN收发器</h3><p>要实现CAN通讯，需要一个CAN收发器和一个CAN控制器</p><p><strong>发信号</strong>：CPU向CAN收发器发送逻辑0或1的电平信号，CAN收发器负责将该信号转换为差分电平输出到CAN总线上，也就是 <code>CAN_H</code>，<code>CAN_L</code>这两根线的电平。</p><p><strong>收信号</strong>：CAN收发器将CAN_H 和 CAN_L 线上传来的差分电平转换为逻辑电平输出到CAN控制器。</p><p><img src="/image-20240131161504903.png" alt="image-20240131161504903"></p><h3 id="CAN总线的基本特点">CAN总线的基本特点</h3><ol><li><p><strong>多主体结构</strong>：CAN网络中的任何节点（例如ECU）都可以主动发送数据，没有固定的主节点。</p><ul><li>也就是说：<strong>在总线空闲状态下，任意节点都可以向总线上发送信息</strong>。</li><li>另外：最先向总线发送信息的节点获得总线的发送权；当多个节点同时向总线发送消息时，所发送消息的优先权高的那个节点获得总线的发送权。</li></ul></li><li><p><strong>消息优先级</strong>：CAN总线使用识别符（ID）来标识消息的优先级，ID值越小，优先级越高。</p><blockquote><p>CAN协议有两种通信方式：标准CAN和扩展CAN。标准CAN使用11位标识符（ID）来标识帧的优先级和发送者，最大传输速率为1Mbps；而扩展CAN使用29位标识符，可以支持更多的节点和更大的数据包，最大传输速率为10Mbps。</p></blockquote></li><li><p><strong>差分信号传输</strong>：CAN总线使用两条线路进行信号传输，即CAN-H（高电平）和CAN-L（低电平），这种差分信号方式<strong>能有效抵抗干扰</strong>。</p></li><li><p><strong>非破坏性仲裁</strong>：在数据传输过程中，如果发生冲突，ID低的节点将继续传输，而不影响其他节点。</p></li><li><p><strong>错误检测与处理</strong>：CAN协议具有强大的错误检测和处理能力，包括校验和、帧检测、位填充等机制。</p></li></ol><h3 id="CAN协议帧结构">CAN协议帧结构</h3><p>CAN协议帧有5种类型，如下所示，先只讲数据帧，其他的以后再补充：</p><p><img src="/image-20240131162514435.png" alt="image-20240131162514435"></p><h4 id="数据帧结构">数据帧结构</h4><p>CAN数据帧主要包括以下几个部分：</p><ol><li><strong>起始位SOF（start of frame）</strong>：1个位的显性位</li></ol><p><img src="/image-20240131205446835.png" alt="image-20240131205446835"></p><ol start="2"><li><strong>仲裁域</strong>：标准格式下ID有11位，拓展格式下ID有29位。<ul><li>包含识别符（ID）和远程传输请求（RTR）位</li><li>ID不仅是设备的身份证，也代表优先级，通过线与机制，逻辑0的优先</li><li>RTR代表类型，用来表示该帧是数据帧还是远程请求帧，由于我们这里是数据帧，所有RTR必须是0。</li></ul></li></ol><img src="/image-20240131205646969.png" alt="image-20240131205646969" style="zoom:80%;" /><ol start="3"><li><p><strong>控制域</strong>：一共有六位。</p><ul><li>IDE用来区分标准格式\拓展格式，用来区分上面的仲裁域。</li><li>DLC（数据长度代码）用来指示数据字段的长度</li><li>r0是预留位（保留位）</li></ul><img src="/image-20240131221909622.png" alt="image-20240131221909622"  /></li><li><p><strong>数据域</strong>：携带实际的数据，最多8字节。</p><p><img src="/image-20240131222018337.png" alt="image-20240131222018337"></p></li><li><p><strong>CRC校验域</strong>：15位，用于错误检测。</p><ul><li>CRC界定符是为了将后面的数据隔开。</li></ul><p><img src="/image-20240131222036452.png" alt="image-20240131222036452"></p></li><li><p><strong>ACK段</strong>：两位，</p><ul><li>第一位是ACK确认槽，发送端是逻辑1，接收端用逻辑0应答。</li><li>第二位是ACK界定符，用来隔开后面的数据，一定是逻辑1</li></ul><p><img src="/image-20240131222111351.png" alt="image-20240131222111351"></p></li><li><p><strong>帧尾</strong>：标志帧的结束。由7个位的隐性位构成。（都是逻辑1）</p><p><img src="/image-20240131222146329.png" alt="image-20240131222146329"></p></li></ol><h3 id="CAN总线的工作原理">CAN总线的工作原理</h3><ul><li>当某个节点需要发送数据时，它会检测总线是否空闲，如果空闲，则开始发送数据。</li><li>如果总线上同时有多个节点开始发送数据，将通过仲裁机制决定优先级最高的节点继续发送。</li><li>接收节点对接收到的数据进行校验，如果没有错误，则发送确认位。</li><li>如果数据传输过程中出现错误，相关节点会发送错误帧，导致当前帧终止。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>segmentation fault调试方法</title>
      <link href="/2024/01/29/segmentation%20fault%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
      <url>/2024/01/29/segmentation%20fault%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>让程序在开发板上直接运行，当它发生错误时，令它产生core dump文件然后使用gdb根据core dump文件找到发生错误的地方</p><ol><li><p>在ARM板上执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure></li><li><p>执行应用程序：程序出错时会在当前目录下生成名为core的文件</p></li><li><p>在PC上执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/arm-linux-gdb ./test_debug ./core</span><br></pre></td></tr></table></figure></li><li><p>backtrace</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v4l2</title>
      <link href="/2024/01/18/v4l2/"/>
      <url>/2024/01/18/v4l2/</url>
      
        <content type="html"><![CDATA[<p>本文仅供自己学习使用</p><h3 id="应用视角">应用视角</h3><p>假如要进行视频数据采集，大体的步骤如下所示：</p><ol><li>打开设备文件/dev/videoX；</li><li>根据打开的设备，查询设备能力集；</li><li>设置视频数据的格式、参数等；</li><li>分配buffer，这个buffer可以是用户态分配的，也可以是从内核中获取的；</li><li>开始视频流采集工作；</li><li>将buffer enqueue到v4l2框架，底层负责将视频数据填充后，应用层再将buffer dequeue以便获取数据，然后再将buffer enqueue，如此循环往复；</li></ol><hr><h4 id="查询能力">查询能力</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_capability</span> <span class="title">cap</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;cap, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_capability));</span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, VIDIOC_QUERYCAP, &amp;cap) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v4l2_capability 的定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_capability</span> &#123;</span></span><br><span class="line">__u8driver[<span class="number">16</span>];</span><br><span class="line">__u8card[<span class="number">32</span>];</span><br><span class="line">__u8bus_info[<span class="number">32</span>];</span><br><span class="line">__u32   version;</span><br><span class="line">__u32capabilities;</span><br><span class="line">__u32device_caps;</span><br><span class="line">__u32reserved[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中的capabilities字段用来表示设备的能力</p><p>用法如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ioctl(fd, VIDIOC_QUERYCAP, &amp;cap) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// output error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(cap.capabilities &amp; V4L2_CAP_STREAMING))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// output error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="枚举格式">枚举格式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_fmtdesc</span> <span class="title">fmtdesc</span>;</span></span><br></pre></td></tr></table></figure><p>其中 v4l2_fmtdesc 如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_fmtdesc</span> &#123;</span></span><br><span class="line">__u32    index;             <span class="comment">/* Format number      */</span></span><br><span class="line">__u32    type;              <span class="comment">/* enum v4l2_buf_type */</span></span><br><span class="line">__u32           flags;</span><br><span class="line">__u8    description[<span class="number">32</span>];   <span class="comment">/* Description string */</span></span><br><span class="line">__u32    pixelformat;       <span class="comment">/* Format fourcc      */</span></span><br><span class="line">__u32    reserved[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>枚举的方式如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fmtdesc.index = fmt_index; <span class="comment">// fmt_index是一个从0递增的数</span></span><br><span class="line">    fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, VIDIOC_ENUM_FMT, &amp;fmtdesc) != <span class="number">0</span>) <span class="comment">// 成功返回0</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    frame_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 枚举这种格式所支持的帧大小 */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;fsenum, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_frmsizeenum));</span><br><span class="line">        fsenum.pixel_format = fmtdesc.pixelformat;</span><br><span class="line">        fsenum.index = frame_index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ioctl(fd, VIDIOC_ENUM_FRAMEINTERVALS, &amp;fsenum) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;format %s, %d, framesize %d: %d x %d\n&quot;</span>, fmtdesc.description,</span><br><span class="line">fmtdesc.pixelformat, frame_index, fsenum.discrete.width, fsenum.discrete.height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        frame_index++;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt_index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="设置格式">设置格式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> <span class="title">fmt</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;fmt, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_format));</span><br><span class="line">fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">fmt.fmt.pix.width = <span class="number">1024</span>;</span><br><span class="line">fmt.fmt.pix.height = <span class="number">768</span>;</span><br><span class="line">fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_JPEG;</span><br><span class="line">fmt.fmt.pix.field = V4L2_FIELD_ANY;</span><br></pre></td></tr></table></figure><p>用的是<code>VIDIOC_S_FMT</code>这个宏</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ioctl(fd, VIDIOC_S_FMT, &amp;fmt) == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;set format ok : %d x %d\n&quot;</span>, fmt.fmt.pix.width, fmt.fmt.pix.height);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t not set format\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="申请buffer">申请buffer</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> <span class="title">rb</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;rb, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_requestbuffers));</span><br><span class="line">rb.count = <span class="number">32</span>;</span><br><span class="line">rb.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">rb.memory = V4L2_MEMORY_MMAP;</span><br></pre></td></tr></table></figure><p>其中<code>v4l2_requestbuffers</code>如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> &#123;</span></span><br><span class="line">__u32count;</span><br><span class="line">__u32type;<span class="comment">/* enum v4l2_buf_type */</span></span><br><span class="line">__u32memory;<span class="comment">/* enum v4l2_memory */</span></span><br><span class="line">__u32capabilities;</span><br><span class="line">__u32reserved[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体操作如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *bufs[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, VIDIOC_REQBUFS, &amp;rb) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    buf_cnt = rb.count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rb.count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_buffer));</span><br><span class="line">        buf.index = i;</span><br><span class="line">        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">        buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ioctl(fd, VIDIOC_QUERYBUF, &amp;buf) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">/* VIDIOC_QUERYBUF:</span></span><br><span class="line"><span class="comment">            *  这个命令在 VIDIOC_REQBUFS 成功后，</span></span><br><span class="line"><span class="comment">            *  用于获取每个已分配缓冲区的详细信息。</span></span><br><span class="line"><span class="comment">            *  这包括缓冲区的起始地址、大小、标志等。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 成功了就 mmap</span></span><br><span class="line">            bufs[i] = mmap(<span class="number">0</span>, buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, buf.m.offset);</span><br><span class="line">            <span class="keyword">if</span> (bufs[i] == MAP_FAILED)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;Unable to map buffer.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;                               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t not request buffer.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map %d buffers ok.\n&quot;</span>, buf_cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t not request buffer.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="把所有buffer放进空闲链表">把所有buffer放进空闲链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; buf_cnt; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_buffer));</span><br><span class="line">    buf.index = i;</span><br><span class="line">    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, VIDIOC_QBUF, &amp;buf) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Unable to queue buffer.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;queue buffers ok.\n&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="启动摄像头">启动摄像头</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, VIDIOC_STREAMON, &amp;type) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t not streamon.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start capture ok\n&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="开始视频流采集工作">开始视频流采集工作</h4><p>例如控制亮度：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建线程，控制亮度 */</span></span><br><span class="line"><span class="type">pthread_t</span> thread;</span><br><span class="line">pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_brightness_control, (<span class="type">void</span> *)fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用poll/select检测buffer，然后从“完成链表”中取出buffer，处理后再放入“空闲链表” */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* poll */</span></span><br><span class="line">    <span class="built_in">memset</span>(fds, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd));</span><br><span class="line">    fds[<span class="number">0</span>].fd = fd;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == poll(fds, <span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 把buffer取出队列 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_buffer));</span><br><span class="line">        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">        buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// VIDIOC_DQBUF 用于从视频缓冲队列中取得一个已经保存有图像数据的缓冲区。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != ioctl(fd, VIDIOC_DQBUF, &amp;buf))</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 把buffer的数据存为文件 */</span></span><br><span class="line">        <span class="built_in">sprintf</span>(filename, <span class="string">&quot;video_raw_data_%04d.jpg&quot;</span>, file_cnt++);</span><br><span class="line">        <span class="type">int</span> fd_file = open(filename, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd_file &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t create file: %s\n&quot;</span>, filename);</span><br><span class="line">        &#125;</span><br><span class="line">        write(fd_file, bufs[buf.index], buf.bytesused);</span><br><span class="line">        close(fd_file);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* VIDIOC_QBUF 用于将已处理过的缓冲区重新放回视频缓冲队列中，以便继续接收数据 */</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(fd, VIDIOC_QBUF, &amp;buf) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;Unable to queue buffer.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中断服务程序thread_brightness_control如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thread_brightness_control</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = (<span class="type">int</span>)args;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> delta;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_queryctrl</span> <span class="title">qctrl</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;qctrl, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_queryctrl));</span><br><span class="line">    qctrl.id = V4L2_CID_BRIGHTNESS;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, VIDIOC_QUERYCTRL, &amp;qctrl) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unable query brightness.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;brightness min: %d, max: %d\n&quot;</span>, qctrl.minimum, qctrl.maximum);</span><br><span class="line">    delta = (qctrl.maximum - qctrl.minimum) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_control</span> <span class="title">ctl</span>;</span></span><br><span class="line">    ctl.id = V4L2_CID_BRIGHTNESS;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ioctl(fd, VIDIOC_G_CTRL, &amp;ctl))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unable set brightness.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = getchar();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;u&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ctl.value += delta;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;d&#x27;</span> || c == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ctl.value -= delta;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ctl.value &gt; qctrl.maximum)</span><br><span class="line">        &#123;</span><br><span class="line">            ctl.value = qctrl.maximum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ctl.value &lt; qctrl.minimum)</span><br><span class="line">        &#123;</span><br><span class="line">            ctl.value = qctrl.minimum;</span><br><span class="line">        &#125;</span><br><span class="line">        ioctl(fd, VIDIOC_S_CTRL, &amp;ctl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="关闭摄像头">关闭摄像头</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ioctl(fd, VIDIOC_STREAMOFF, &amp;type) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t not streamoff.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;stop capture ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><hr><h3 id="驱动视角">驱动视角</h3><p>对于复杂的字符设备，内核都是采用分层的方法，一般分<strong>驱动核心层</strong>还有<strong>硬件相关层</strong></p><p>核心层会帮你完成字符设备的分配，fops的设置，注册字符设备，并向硬件相关层提供一个相应的对象和注册接口</p><p>硬件相关层则需要分配相应的对象，设置对象和对象的fops，并注册到核心层中</p><p>当应用层发生系统调用，会先来到核心层，核心层再通过回调函数调用到硬件相关层的驱动<br>对于V4L2的驱动框架也是如此，可分为<strong>V4L2驱动核心层</strong>和<strong>硬件相关层</strong></p><p>下面先用一张图来总结大致V4L2的驱动框架</p><img src="/image-20240119142954335.png" alt="image-20240119142954335" style="zoom:80%;" /><h4 id="数据结构">数据结构</h4><ul><li><p>v4l2驱动框架主要的对象有<code>video_device</code>、<code>v4l2_device</code>、<code>v4l2_subdev</code></p></li><li><p>v4l2_device代表整个输入设备，以v4l2_subdev来代表子模块，比如CSI、Sensor等；</p></li><li><p><code>v4l2_device</code>里有一个<code>v4l2_subdev</code>链表，可以选择<code>v4l2_device</code>去控制哪一个<code>v4l2_subdev</code></p></li></ul><p><img src="/123.png" alt=""></p><p>源码可以在<code>Linux/include/media/v4l2-dev.h</code>中查看：</p><h5 id="video-device">video_device</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">video_device</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* character device */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">cdev</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* v4l2_device parent */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_device</span> *<span class="title">v4l2_dev</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* device ops */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_file_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* ioctl callbacks */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_ioctl_ops</span> *<span class="title">ioctl_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到video_device中含有一个cdev还有v4l2_device，此外还有fops和ioctl_ops，从应用层进行系统调用会经过v4l2的核心层回调到这里</p><p>其中<code>v4l2_file_operations</code>和<code>v4l2_ioctl_ops</code>如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_file_operations</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line"><span class="type">long</span> (*ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*release) (<span class="keyword">struct</span> file *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>熟悉v4l2应用编程的应该都知道v4l2有很多ioctl操作，具体实现都在这里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_ioctl_ops</span> &#123;</span></span><br><span class="line"><span class="type">int</span> (*vidioc_querycap)(<span class="keyword">struct</span> file *file, <span class="type">void</span> *fh, <span class="keyword">struct</span> v4l2_capability *cap);</span><br><span class="line"><span class="comment">/* Buffer handlers */</span></span><br><span class="line"><span class="type">int</span> (*vidioc_reqbufs) (<span class="keyword">struct</span> file *file, <span class="type">void</span> *fh, <span class="keyword">struct</span> v4l2_requestbuffers *b);</span><br><span class="line"><span class="type">int</span> (*vidioc_querybuf)(<span class="keyword">struct</span> file *file, <span class="type">void</span> *fh, <span class="keyword">struct</span> v4l2_buffer *b);</span><br><span class="line"><span class="type">int</span> (*vidioc_qbuf)    (<span class="keyword">struct</span> file *file, <span class="type">void</span> *fh, <span class="keyword">struct</span> v4l2_buffer *b);</span><br><span class="line"><span class="type">int</span> (*vidioc_dqbuf)   (<span class="keyword">struct</span> file *file, <span class="type">void</span> *fh, <span class="keyword">struct</span> v4l2_buffer *b);</span><br><span class="line">    <span class="comment">/* Stream on/off */</span></span><br><span class="line"><span class="type">int</span> (*vidioc_streamon) (<span class="keyword">struct</span> file *file, <span class="type">void</span> *fh, <span class="keyword">enum</span> v4l2_buf_type i);</span><br><span class="line"><span class="type">int</span> (*vidioc_streamoff)(<span class="keyword">struct</span> file *file, <span class="type">void</span> *fh, <span class="keyword">enum</span> v4l2_buf_type i);</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="v4l2-device">v4l2_device</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_device</span> &#123;</span></span><br><span class="line"><span class="comment">/* used to keep track of the registered subdevs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">subdevs</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到v4l2_device中有一个v4l2_subdev的链表，v4l2_device的主要目的时用来管理v4l2_subdev</p><h5 id="v4l2-subdev">v4l2_subdev</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_subdev</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_device</span> *<span class="title">v4l2_dev</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_subdev_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>v4l2_subdev中有一个v4l2_subdev_ops，实现了一系列的操作，供v4l2_device调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_subdev_ops</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_subdev_core_ops</span>*<span class="title">core</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_subdev_tuner_ops</span>*<span class="title">tuner</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_subdev_audio_ops</span>*<span class="title">audio</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_subdev_video_ops</span>*<span class="title">video</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_subdev_vbi_ops</span>*<span class="title">vbi</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_subdev_ir_ops</span>*<span class="title">ir</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_subdev_sensor_ops</span>*<span class="title">sensor</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="V4L2提供的注册接口">V4L2提供的注册接口</h4><ul><li>video_device</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">video_register_device</span><span class="params">(<span class="keyword">struct</span> video_device *vdev, <span class="type">int</span> type, <span class="type">int</span> nr)</span>;<span class="comment">// 注册</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">video_unregister_device</span><span class="params">(<span class="keyword">struct</span> video_device *vdev)</span>;<span class="comment">// 注销</span></span><br></pre></td></tr></table></figure><ul><li>v4l2_device</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">v4l2_device_register</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> v4l2_device *v4l2_dev)</span>; <span class="comment">// 注册</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">v4l2_device_unregister</span><span class="params">(<span class="keyword">struct</span> v4l2_device *v4l2_dev)</span>; <span class="comment">// 注销</span></span><br></pre></td></tr></table></figure><ul><li>v4l2_subdev</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">v4l2_device_register_subdev</span><span class="params">(<span class="keyword">struct</span> v4l2_device *v4l2_dev, <span class="keyword">struct</span> v4l2_subdev *sd)</span>;  <span class="comment">// 注册</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">v4l2_device_unregister_subdev</span><span class="params">(<span class="keyword">struct</span> v4l2_subdev *sd)</span>;  <span class="comment">// 注销</span></span><br></pre></td></tr></table></figure><hr><h4 id="源码剖析">源码剖析</h4><h5 id="V4L2驱动模板">V4L2驱动模板</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;...&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">video_device</span>* <span class="title">video_dev</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_device</span> <span class="title">v4l2_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现各种系统调用 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_file_operations</span> <span class="title">video_dev_fops</span> =</span> &#123;</span><br><span class="line">.owner    = THIS_MODULE,</span><br><span class="line">.release        = vdev_close,</span><br><span class="line">.read           = vdev_read,</span><br><span class="line">.poll    = vdev_poll,</span><br><span class="line">.ioctl          = video_ioctl2,</span><br><span class="line">.mmap           = vdev_mmap,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现各种系统调用 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_ioctl_ops</span> <span class="title">video_dev_ioctl_ops</span> =</span> &#123;</span><br><span class="line">.vidioc_querycap      = vidioc_querycap,</span><br><span class="line">.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,</span><br><span class="line">.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,</span><br><span class="line">.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,</span><br><span class="line">.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,</span><br><span class="line">.vidioc_reqbufs       = vidioc_reqbufs,</span><br><span class="line">.vidioc_querybuf      = vidioc_querybuf,</span><br><span class="line">.vidioc_qbuf          = vidioc_qbuf,</span><br><span class="line">.vidioc_dqbuf         = vidioc_dqbuf,</span><br><span class="line">.vidioc_enum_input    = vidioc_enum_input,</span><br><span class="line">.vidioc_g_input       = vidioc_g_input,</span><br><span class="line">.vidioc_s_input       = vidioc_s_input,</span><br><span class="line">.vidioc_streamon      = vidioc_streamon,</span><br><span class="line">.vidioc_streamoff     = vidioc_streamoff,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">video_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 分配并设置一个video_device */</span></span><br><span class="line">    video_dev = video_device_alloc();</span><br><span class="line">    video_dev-&gt;fops = &amp;video_dev_fops;</span><br><span class="line">    video_dev-&gt;ioctl_ops = &amp;video_dev_ioctl_ops;</span><br><span class="line">    video_dev-&gt;release = video_device_release;</span><br><span class="line">    video_dev-&gt;tvnorms = V4L2_STD_525_60;</span><br><span class="line">    video_dev-&gt;current_norm = V4L2_STD_NTSC_M;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册一个v4l2_device */</span></span><br><span class="line">    v4l2_device_register(video_dev-&gt;dev, &amp;v4l2_dev);    </span><br><span class="line">    video_dev-&gt;v4l2_dev = &amp;video_dev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册一个video_device字符设备 */</span></span><br><span class="line">    video_register_device(video_dev, VFL_TYPE_GRABBER, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">video_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    video_unregister_device(video_dev);</span><br><span class="line">    v4l2_device_unregister(&amp;v4l2_dev);</span><br><span class="line">    video_device_release(video_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(video_init);</span><br><span class="line">module_exit(video_exit); </span><br></pre></td></tr></table></figure><p>如果你熟悉v4l2应用编程的话，你应该知道v4l2有许多ioctl操作，上面的模板就实现了很多ioctl操作</p><h5 id="V4L2源码剖析">V4L2源码剖析</h5><p>在上面的video_init中，我们分配并设置了video_dev，注册了v4l2_device(v4l2_device_register)，然后向v4l2核心层注册video_device(video_register_device)</p><p>我们先来看v4l2_device_register</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">v4l2_device_register</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> v4l2_device *v4l2_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    INIT_LIST_HEAD(&amp;v4l2_dev-&gt;subdevs);</span><br><span class="line">    spin_lock_init(&amp;v4l2_dev-&gt;lock);</span><br><span class="line">    dev_set_drvdata(dev, v4l2_dev);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出<code>v4l2_device_register</code>并没有做什么事，只是初始化链表，自旋锁，还有设置数据，这函数并不是我们的重点</p><p>下面来仔细分析<code>video_register_device</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">video_register_device</span><span class="params">(<span class="keyword">struct</span> video_device *vdev, <span class="type">int</span> type, <span class="type">int</span> nr)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">/* 分配字符设备 */</span></span><br><span class="line">    vdev-&gt;cdev = cdev_alloc();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置fops */</span></span><br><span class="line">    vdev-&gt;cdev-&gt;ops = &amp;v4l2_fops;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 注册字符设备 */</span></span><br><span class="line">    cdev_add(vdev-&gt;cdev, MKDEV(VIDEO_MAJOR, vdev-&gt;minor), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成设备节点 */</span></span><br><span class="line">dev_set_name(&amp;vdev-&gt;dev, <span class="string">&quot;%s%d&quot;</span>, name_base, vdev-&gt;num);</span><br><span class="line">    device_register(&amp;vdev-&gt;dev);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置全局数组 */</span></span><br><span class="line">    video_device[vdev-&gt;minor] = vdev;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>可以看到这个函数会为video_device分配一个cdev，然后设置fops，向内核注册字符设备，再者生成设备节点</p><p>然后设置video_device全局数组，video_device一个全局数组</p><p>接下来看一下其中设置的fops(v4l2_fops)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">v4l2_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.read = v4l2_read,</span><br><span class="line">.write = v4l2_write,</span><br><span class="line">.open = v4l2_open,</span><br><span class="line">.get_unmapped_area = v4l2_get_unmapped_area,</span><br><span class="line">.mmap = v4l2_mmap,</span><br><span class="line">.ioctl = v4l2_ioctl,</span><br><span class="line">.release = v4l2_release,</span><br><span class="line">.poll = v4l2_poll,</span><br><span class="line">.llseek = no_llseek,</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>这个是video_device中的字符设备对应的fops，应用层发生系统调用会率先调用到这里，我们来好好看一看这些调用</p><ul><li>v4l2_open</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">v4l2_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        inode 结构表示文件系统中的一个节点，包含了文件的元数据信息。</span></span><br><span class="line"><span class="comment">        filp 结构表示打开的文件，包含了文件相关的信息。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">video_device</span> *<span class="title">vdev</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 根据次设备获得video_device </span></span><br><span class="line"><span class="comment">       video_devdata 是 V4L2 框架提供的一个宏，</span></span><br><span class="line"><span class="comment">       用于从文件指针中提取关联的 struct video_device。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    vdev = video_devdata(filp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 回调video_device的fops */</span></span><br><span class="line"><span class="keyword">if</span> (vdev-&gt;fops-&gt;open)</span><br><span class="line">ret = vdev-&gt;fops-&gt;open(filp); <span class="comment">//回调video</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从这个函数可以看到，发生系统调用首先来到v4l2核心层的字符设备，然后再回调到对应的video_device，video_device在前面已经实现了<code>v4l2_file_operations</code>和<code>v4l2_ioctl_ops</code>一系列回调</p><ul><li>v4l2_ioctl</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">v4l2_ioctl</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">video_device</span> *<span class="title">vdev</span> =</span> video_devdata(filp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 回调到video_device中 */</span></span><br><span class="line"><span class="keyword">return</span> vdev-&gt;fops-&gt;ioctl(filp, cmd, arg);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>下面来看一看video_device怎么实现ioctl</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_file_operations</span> <span class="title">video_dev_fops</span> =</span> &#123;</span><br><span class="line">.owner    = THIS_MODULE,</span><br><span class="line">.release        = vdev_close,</span><br><span class="line">.read           = vdev_read,</span><br><span class="line">.poll    = vdev_poll,</span><br><span class="line">.ioctl          = video_ioctl2,</span><br><span class="line">.mmap           = vdev_mmap,</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>从上面驱动程序的编写，我们可以知道video_device对应ioctl就是video_ioctl2，这个函数是内核提供的，我们看一看这个函数的内容</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">video_ioctl2</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    __video_do_ioctl(file, cmd, parg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> __video_do_ioctl(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 获取video_device */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">video_device</span> *<span class="title">vfd</span> =</span> video_devdata(file);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获取video_device的ioctl_ops */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_ioctl_ops</span> *<span class="title">ops</span> =</span> vfd-&gt;ioctl_ops;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> VIDIOC_QUERYCAP:</span><br><span class="line">        ops-&gt;vidioc_querycap(file, fh, cap);</span><br><span class="line">    <span class="keyword">case</span> VIDIOC_ENUM_FMT:</span><br><span class="line">         ops-&gt;vidioc_enum_fmt_vid_cap(file, fh, f);</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>可以看出，最终会调用到video_device实现的<code>v4l2_ioctl_ops</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 实现各种系统调用 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_ioctl_ops</span> <span class="title">video_dev_ioctl_ops</span> =</span> &#123;</span><br><span class="line">.vidioc_querycap      = vidioc_querycap,</span><br><span class="line">.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,</span><br><span class="line">.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,</span><br><span class="line">.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,</span><br><span class="line">.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,</span><br><span class="line">.vidioc_reqbufs       = vidioc_reqbufs,</span><br><span class="line">.vidioc_querybuf      = vidioc_querybuf,</span><br><span class="line">.vidioc_qbuf          = vidioc_qbuf,</span><br><span class="line">.vidioc_dqbuf         = vidioc_dqbuf,</span><br><span class="line">.vidioc_enum_input    = vidioc_enum_input,</span><br><span class="line">.vidioc_g_input       = vidioc_g_input,</span><br><span class="line">.vidioc_s_input       = vidioc_s_input,</span><br><span class="line">.vidioc_streamon      = vidioc_streamon,</span><br><span class="line">.vidioc_streamoff     = vidioc_streamoff,</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>所以系统调用最先都会调用到字符设备的fops，然后经过v4l2核心层最终调用到video_device这里</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海康面试</title>
      <link href="/2023/12/26/%E6%B5%B7%E5%BA%B7%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/12/26/%E6%B5%B7%E5%BA%B7%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<ol><li><p>自我介绍</p></li><li><p>C语言中的static</p></li><li><p>数组和链表的优缺点</p><ul><li>数组，在内存上给出了连续的空间。链表,内存地址上可以是不连续的。</li><li>数组是查询快，在中间部分插入和删除元素速度相对较慢。 链表是查询慢，但是插入和删除元素快</li></ul></li><li><p>消息队列</p></li><li><p>消息队列和直接调用相比有什么好处</p></li><li><p>虚拟内存和物理内存，有什么优点</p></li><li><p>进程间的通信方式</p></li><li><p>频繁创建线程有什么缺点？</p></li><li><p>如何改进频繁创建线程</p></li><li><p>多进程和单进程（多线程）的优缺点</p></li><li><p>进程和线程有哪些开销。</p></li><li><p>介绍TCP和UDP。传输效率哪个高。分别有哪些应用场景</p></li><li><p>有无做过TCP相关功能？</p></li><li><p>TCP创建套接字的步骤？有无做过UDP相关功能？</p></li><li><p>FTP协议是网络协议中的哪一层</p></li><li><p>MQTT协议的工作方式</p></li><li><p>MySQL？</p></li><li><p>查看虚拟内存，网络连接，cpu消耗分别有什么常用的linux指令</p></li><li><p>文件操作指令 seek</p></li><li><p>开发过程中排查问题最难的一次经验</p></li><li><p>介绍简历里的项目</p></li><li><p>介绍竞赛，队内怎么协同合作？</p></li><li><p>除了简历上的还有没有别的项目？</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节面试</title>
      <link href="/2023/12/19/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/12/19/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<ol><li>自我介绍</li><li>做过什么驱动，流程？(类似项目里驱动实现的方法，是什么类型的设备）</li><li>设备树中有两个一样的compatible字段要怎么去区分</li><li>内核剪裁的思路</li><li>怎么通过压缩进行剪裁</li><li>uboot 启动流程？芯片上电后发生了什么？</li><li>arm大小核的概念？</li><li>ATF？（BL1， BL2， BL31， BL32，BL33）</li><li>多核处理器是怎么启动的？</li></ol><p>部门介绍：主要做固件驱动。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mosquitto安装/配置/使用</title>
      <link href="/2023/11/28/mosquitto%E5%AE%89%E8%A3%85-%E9%85%8D%E7%BD%AE-%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/11/28/mosquitto%E5%AE%89%E8%A3%85-%E9%85%8D%E7%BD%AE-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="改配置文件mosquitto-conf">改配置文件mosquitto.conf</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">password_file /Program Files/mosquitto/pwfile.example</span><br></pre></td></tr></table></figure><h4 id="创建-添加-用户">创建/添加 用户</h4><ol><li>创建：mosquitto_passwd -c pwfile.example admin</li><li>添加：mosquitto_passwd  pwfile.example admin</li></ol><h4 id="常用的几个指令参数">常用的几个指令参数</h4><p>-c 加载指定的配置文件，即mosquitto.conf</p><p>-d 将服务放在后台执行</p><p>-p 监听指定端口的代理，并且不建议与-c选项一起使用</p><p>-v 启用详细日志模式</p><h4 id="启动mosquitto服务">启动mosquitto服务</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mosquitto <span class="literal">-c</span> mosquitto.conf <span class="literal">-v</span> </span><br></pre></td></tr></table></figure><h4 id="订阅">订阅</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mosquitto_sub <span class="literal">-v</span> <span class="literal">-t</span> <span class="comment">#</span></span><br></pre></td></tr></table></figure><h4 id="发布">发布</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mosquitto_pub <span class="literal">-t</span> topic <span class="literal">-m</span> <span class="string">&quot;Hello world!&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列</title>
      <link href="/2023/11/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2023/11/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>消息队列是一种进程间通信的机制，它允许不同的进程通过在消息队列中发送和接收消息来进行通信。消息队列通常被用于解耦不同模块或进程之间的通信，提高系统的可扩展性和灵活性。</p><h3 id="消息队列的特点">消息队列的特点</h3><ol><li><strong>异步通信：</strong> 发送方将消息放入队列后即可继续执行，而不需要等待接收方的处理。</li><li><strong>解耦性：</strong> 发送方和接收方不需要直接知道对方的存在，只需了解消息队列的接口即可。</li><li><strong>削峰</strong>:</li><li><strong>缓冲：</strong> 消息队列允许暂存消息，即使接收方暂时不可用，消息也不会丢失。</li></ol><h3 id="实现消息队列的步骤">实现消息队列的步骤</h3><p>实现消息队列通常包括以下步骤：</p><ol><li><p><strong>创建消息队列：</strong> 操作系统提供了创建消息队列的API。在Linux中，可以使用<code>msgget</code>函数创建消息队列。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>发送消息：</strong> 发送方使用消息队列的发送API将消息发送到队列中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>接收消息：</strong> 接收方使用消息队列的接收API从队列中取出消息。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除消息队列：</strong> 在通信结束后，可以使用相应的API删除消息队列。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="示例代码（使用Linux的System-V消息队列）">示例代码（使用Linux的System V消息队列）</h3><p>以下是一个简单的C语言示例代码，展示了如何创建、发送和接收消息队列中的消息：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;<span class="comment">/* message type, must be &gt; 0 */</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">100</span>];<span class="comment">/* message data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;/tmp&quot;</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">// Generate a unique key</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> msqid = msgget(key, <span class="number">0666</span> | IPC_CREAT); <span class="comment">// Create or get the message queue</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">message</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send a message</span></span><br><span class="line">    message.mtype = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">sprintf</span>(message.mtext, <span class="string">&quot;Hello, Message Queue!&quot;</span>);</span><br><span class="line">    msgsnd(msqid, &amp;message, <span class="keyword">sizeof</span>(message.mtext), IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Receive a message</span></span><br><span class="line">    msgrcv(msqid, &amp;message, <span class="keyword">sizeof</span>(message.mtext), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>, message.mtext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove the message queue</span></span><br><span class="line">    msgctl(msqid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此示例创建了一个消息队列，发送了一条消息，并在另一个进程中接收该消息。最后，删除了消息队列。请注意，实际应用中需要适当处理错误和边界情况。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>平台设备驱动模型</title>
      <link href="/2023/11/25/%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/11/25/%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_platform.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义设备私有数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_platform_data</span> &#123;</span></span><br><span class="line">    <span class="comment">// 这里可以包含设备特定的信息</span></span><br><span class="line">    <span class="type">int</span> some_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Probe 函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_platform_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Probe function called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从设备树获取信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="keyword">if</span> (!np) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Device tree node not found\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析设备树中的信息，这里只是一个简单的示例</span></span><br><span class="line">    data = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> my_platform_data), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to allocate memory for private data\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以根据设备树中的属性设置设备特定的信息</span></span><br><span class="line">    of_property_read_u32(np, <span class="string">&quot;some_data&quot;</span>, &amp;data-&gt;some_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将私有数据关联到平台设备上</span></span><br><span class="line">    platform_set_drvdata(pdev, data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以进行其他设备初始化的工作</span></span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Platform device probed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove 函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Remove function called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以进行设备的反初始化工作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备树匹配表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_platform_of_match</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;my,platform-device&quot;</span>, &#125;,</span><br><span class="line">    &#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(of, my_platform_of_match);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备驱动结构</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my-platform-driver&quot;</span>,</span><br><span class="line">        .of_match_table = my_platform_of_match,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    pr_info(<span class="string">&quot;My platform driver module loaded\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line">    pr_info(<span class="string">&quot;My platform driver module unloaded\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_init);</span><br><span class="line">module_exit(my_platform_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Your Name&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;My Platform Driver&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入子系统の驱动框架</title>
      <link href="/2023/11/23/%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E3%81%AE%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/11/23/%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E3%81%AE%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>本文<strong>参考</strong>了CSDN博主「陈 洪 伟」的原创文章<br>原文链接：<a href="https://blog.csdn.net/u013171226/article/details/133985487">https://blog.csdn.net/u013171226/article/details/133985487</a></p><h3 id="1、前言">1、前言</h3><p>输入子系统提供了一种通用的机制，用于处理各种输入设备，如键盘、鼠标、触摸屏等。</p><p>换句话说，就是将大部分的输入设备抽象出一个公共层出来，方便应用层使用</p><hr><h3 id="2、输入子系统层次结构">2、输入子系统层次结构</h3><p><img src="image-20231216151859600.png" alt="image-20231216151859600"></p><h4 id="2-1事件处理层：input-handler">2.1事件处理层：input_handler</h4><ol><li>事情处理层主要是负责将输入事件上报到应用程序；对于已经向内核输入子系统注册的输入设备，在sysfs中创建设备节点，应用程序通过操作设备节点来获取输入事件。</li><li>事件处理层将输入事件划分为几大类，比如：通用事件(event)、鼠标事件(mouse)、摇杆事件(js)等等，每个输入类设备在注册时需要指定自己属于哪个类；</li><li>通用事件是能和任何输入设备匹配上的，意味着只要注册一个输入类设备就会sysfs就会创建对应的<code>/dev/input/eventn</code>设备节点；</li></ol><h4 id="2-2-核心层：input-handle">2.2 核心层：input_handle</h4><p>承上启下。为设备驱动层提供了规范和接口；通知事件处理层对事件进行处理；事件处理层和设备驱动层都必须先向核心层注册，然后才能工作；</p><ul><li><ol><li>申请主设备号</li><li>提供input_register_device跟input_register_handler函数分别用于注册device跟handler;</li><li>提供input_register_handle函数用于注册一个事件处理，代表一个成功配对的input_dev和input_handler;</li></ol></li></ul><h4 id="2-3-驱动层：intut-dev">2.3 驱动层：intut_dev</h4><p>把硬件产生的事件转换为核心层定义的规范提交给事件处理层。</p><hr><h3 id="3、关键数据结构">3、关键数据结构</h3><h4 id="3-1-input-handler">3.1 input_handler</h4><ul><li>即<strong>事件处理驱动</strong>，在内核启动过程中会向核心层注册handler；</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> *private; <span class="comment">//由具体的事件处理程序指定的私有数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于处理送到事件处理层的事件，该方法由核心层调用，调用时已经禁止了中断，</span></span><br><span class="line"><span class="comment">//并获得dev-&gt;event lock ，因此不能喔珉</span></span><br><span class="line"><span class="type">void</span> (*event)(<span class="keyword">struct</span> input_handle *handle, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> (*filter)(<span class="keyword">struct</span> input_handle *handle, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value);</span><br><span class="line"><span class="type">bool</span> (*match)(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在事件处理程序关联到一个输入设备时调用</span></span><br><span class="line"><span class="type">int</span> (*connect)(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev, <span class="type">const</span> <span class="keyword">struct</span> input_device_id *id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在事件处理程序脱离与之关联的输入设备时调</span></span><br><span class="line"><span class="type">void</span> (*disconnect)(<span class="keyword">struct</span> input_handle *handle);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span> <span class="comment">//该事件处理驱动的文件操作集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入设备 ID衰，事件处理驱动通过这个成员来匹配它能处理的设备</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">h_list</span>;</span><span class="comment">//该事件处理程序关联的输入句柄列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">node</span>;</span><span class="comment">//所有有事件处理驱动都会通过该成员连接到 input_handler_list链表上</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-2-input-handle">3.2 input_handle</h4><ul><li><code>struct handle</code>连接了输入设备 (<code>input_dev</code>) 和事件处理驱动(<code>input_handler</code>)。有了handle之后，设备上报输入事件时才知道该往哪些事件处理驱动上报；</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *private; <span class="comment">//由事件处理程序指定的私有数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> open;<span class="comment">//记录句柄打开的次数 </span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//处理程序创建该句柄时，指定的句柄名称＊</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span><span class="comment">//该句柄关联的输入设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span> <span class="comment">//句柄关联的事件处理程序</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">d_node</span>;</span><span class="comment">// 维护 dev 链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">h_node</span>;</span><span class="comment">// 维护 handle 链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-3-input-dev">3.3 input_dev</h4><ul><li>每个输入设备都有一个<code>input_dev</code>，<strong>用来抽象一个输入设备</strong>。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//设备名称</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *phys;<span class="comment">//设备在系统中的物理路径</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *uniq;<span class="comment">//设备唯一识别符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span><span class="comment">//设备工D，包含总线ID(PCI 、 USB)、厂商工D,与 input handler 匹配的时会用到</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)];<span class="comment">//设备支持的事件类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">h_list</span>;</span><span class="comment">// 维护与该设备相关的 handle</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">node</span>;</span><span class="comment">// 挂接到input_dev_list链表上</span></span><br><span class="line">...    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-4-input-dev、input-handler、input-handle三者的关系">3.4 input_dev、input_handler、input_handle三者的关系</h4><ol><li>input_handle结构体是用于记录匹配上的输入设备和事件处理驱动的，当设备驱动和事件处理驱动匹配上时就会新建一个handle并向核心层注册；</li><li>input_dev结构体中有h_list链表，里面记录的是设备对应的handle结构体</li><li>input_handler结构体中有h_list链表，里面记录的是设备对应的handle结构体；</li><li>handle结构体里的d_node是记录匹配上的input_dev结构体，h_node是记录的handler结构体；</li><li>如果知道handle结构体，可以通过d_node链表找到对应的input_dev结构体，通过h_node链表找到对应的handler结构体；</li><li>如果知道input_dev结构体，可以通过h_list链表找到handle结构体，再通过handle结构体的h_node链表找到匹配的handler结构体；</li><li>如果知道handler结构体，可以通过h_list链表找到handle结构体，再通过handle结构体的d_node链表找到匹配的input_dev结构体；</li></ol><blockquote><p>总结：<strong>三个结构体通过链表互相关联，只要知道其中一个就能通过链表找到另外两个</strong>；</p></blockquote><hr><h3 id="4、input子系统驱动框架分析">4、input子系统驱动框架分析</h3><p><img src="b4ed96f48c9142b8ab4a07c06dd0d6fe-17027142639248.png" alt="img"></p><p>如上图所示为输入子系统的设备层，核心层和处理层之间的关系，当我们用input_register_handler 函数添加handler的时候，会将其添加到input.c里面的一个链表中，同样当我们用input_register_device添加input_dev的时候，会将其添加到input.c的input_dev链表中，然后无论是我们添加handler还是添加device，内核都会对两者进行match，当发现某个device和handler相匹配的时候，就会调用handler里面的connect函数，然后再connect函数里面去申请input_handle结构体，这个input_handle结构体里面保存着匹配的input_handler和input_dev。</p><h4 id="4-1-怎么添加input-dev">4.1 怎么添加input_dev</h4><p>接下来将分别看一下我们怎么添加input_dev也就是上图中的左下角的input_dev是怎么被添加上的，然后再看一下右边connect函数内部的细节。</p><p><img src="1bfc2a9fe8d24c16ae8a7aaa288ec607.png" alt="img"></p><p>上图是以内核中的按键输入驱动为例，看一下是怎么添加input_dev的，从左边可以看到，首先我们编写设备树文件，然后设备树文件会被解析成platform_device，然后利用函数of_device_add添加到platform_bus_type的设备链表中，然后我们还会编写一个platform_driver驱动结构体，然后利用platform_driver_register函数将驱动注册内核中，无论我们添加驱动还是添加设备，内核都会去对设备和驱动进行匹配，匹配成功后就会调用驱动结构体里面的probe函数，也就是上图中的gpio_keys_probe函数，然后在probe函数中ongoing会申请input_dev结构体，并且利用input_register_device函数将设备注册到input系统的设备链表中。<br><img src="939a5edf69694f1dae11c834560af3b5.png" alt="img"></p><p>上图是以内核中的I2C接口的触摸屏驱动为例，看一下怎么添加input_dev的，这个图和前面的按键那个图类似，注意区别就是，对于i2c设备来说，它是挂载i2c_bus_type上面的不是platform_bus上的，其他的地方是类似的，就不再赘述了。</p><p>这里需要补充的一点是在connect函数中还有一个gtp_request_irq(ts);函数，这里是申请中断的，然后进一步调用了ret = request_threaded_irq(ts-&gt;client-&gt;irq, NULL,gtp_irq_handler,ts-&gt;pdata-&gt;irq_flags | IRQF_ONESHOT,ts-&gt;client-&gt;name,ts);函数，这里设置了中断处理函数是gtp_irq_handler，在gtp_irq_handler函数里面就是真正读取触摸屏数据的最底层的硬件函数了，里面就是调用i2c_transfer函数读取数据的了。</p><h4 id="4-2-input-dev和input-handler匹配后，connec函数做了什么">4.2 input_dev和input_handler匹配后，connec函数做了什么</h4><p><img src="45b5f8f7613948718dd6a2b153515055.png" alt="img"></p><p>前面看了怎么把input_dev添加到内核中，接下来看一下当input_dev和input_handler匹配后调用connect函数内部的细节，上图就是connect函数内部细节流程，</p><p>在connect函数里面我们可以猜一下，无非就是分配、设置、注册结构体，具体看一下里面，首先是申请了一个evdev结构体，然后我们可以看到这个evdev结构体里面又包含了input_handle结构体，然后这个input_handle结构体里面有两个重要成员就是input_dev和input_handler,这两个就是用来保存匹配的input_dev和input_handler的；</p><p>再往下可以看到list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);和list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);，这两个函数的意思就是把handle又分别保存到了input_handler和input_dev的链表中了。</p><p>再往下就是注册字符设备驱动程序，其中包含一个file_operations结构体，那么当应用程序调用open/read/write函数的时候就会调用这里的file_ops结构体里面的函数。</p><h3 id="5、-input子系统读数据流程">5、 input子系统读数据流程</h3><p>接下来我们看一下读取input输入事件数据的流程，先看一下open的流程。</p><h4 id="5-1-open输入设备流程">5.1 open输入设备流程</h4><p><img src="c1537998752a4c6db369213b71a871d0.png" alt="img"></p><p>上图就是open打开输入设备的流程，当我们调用open函数时，进一步会调用evdev_fops结构体里面的evdev_open函数，这个函数里面首先申请一个client，这个client就对应着我们的用户程序，然后会将这个client和evdev进行绑定，也就是把用户和输入设备绑定了。</p><h4 id="5-2-read读取输入事件流程">5.2 read读取输入事件流程</h4><p><img src="78e67f593ca545669e4494695d883050.png" alt="img"></p><p>如上图所示是read流程，先从最上面开始看，当应用程序调用read函数时，进一步会调用到evdev_read函数，然后在evdev_read函数中，如果有数据那么直接读取，如果没有数据，那么休眠等待。</p><p>好了，接下来再从图的最下面往上看，前面说了没数据就休眠，然后过一会硬件输入设备被操作了或者被按下了，然后就会产生中断，这时候就会进入中断处理函数，然后就会利用处理函数gpio_keys_gpio_work_func进行处理，然后这个函数一层层看下去最终就是调用input_event上报输入事件。</p><p>然后input_event其实就是核心层了，然后看一下input_event函数做了什么，这个函数一层层调用最终是调用到了input_to_handler函数，这个函数的源码大体可以看到，如果input_handler定义了filter就用filter函数处理，如果定义了input_handler-&gt;events函数那就用events函数处理，这里就是用events处理的。</p><p>那么这时候就去看input_handler-&gt;events函数，这个函数里面利用__pass_event(client, &amp;event);把数据传给client,这个client是在open时候分配的。然后唤醒前面休眠的程序，这时候evdev_read函数就会被唤醒，然后读取输入事件。</p><p>至此，输入事件的read过程结束。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux字符设备驱动</title>
      <link href="/2023/11/21/Linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/11/21/Linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1、前言">1、前言</h3><p>众所周知，<code>Linux</code>内核主要包括三种驱动模型，字符设备驱动，块设备驱动以及网络设备驱动。</p><p>其中，<code>Linux</code>字符设备驱动，可以说是<code>Linux</code>驱动开发中最常见的一种驱动模型。</p><hr><h3 id="2、关键数据结构">2、关键数据结构</h3><h4 id="2-1-cdev">2.1 cdev</h4><p>可以理解为<code>char device</code>，主要作用是<strong>用来抽象一个字符设备。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">dev_t</span> dev;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p><strong>核心成员及含义</strong>：</p><ul><li><code>kobj</code>：表示一个内核对象。</li><li><code>owner</code>：指向该模块的指针</li><li><code>ops</code>：指向文件操作的指针，包括<code>open</code>、<code>read</code>、<code>write</code>等操作接口</li><li><code>list</code>：用于将该设备加入到内核模块链表中</li><li><code>dev</code>：设备号，由主设备号和次设备号构成</li><li><code>count</code>：表示有多少个同类型设备，也间接表示设备号的范围</li><li><code>__randomize_layout</code>：一个编译器指令，用于随机化结构体的布局，以增加安全性。</li></ul><h4 id="2-2-file-operations">2.2 file_operations</h4><p><strong>主要作用</strong>：正如其名，主要用来描述文件操作的各种接口，<code>Linux</code>一切接文件的思想，内核想要操作哪个文件，都需要通过这些接口来实现。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">    <span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">    <span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">    <span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line">    <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">    <span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line">    <span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">              <span class="type">loff_t</span> len);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line">            <span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*clone_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *, <span class="type">loff_t</span>,</span><br><span class="line">            u64);</span><br><span class="line">    <span class="type">int</span> (*dedupe_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *, <span class="type">loff_t</span>,</span><br><span class="line">            u64);</span><br><span class="line">    <span class="type">int</span> (*fadvise)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p><strong>核心成员及含义</strong>：</p><ul><li><code>open</code>：打开文件的函数</li><li><code>read</code>：读取文件的函数。</li><li><code>write</code>：写入文件的函数。</li><li><code>release</code>：关闭文件的函数。</li><li><code>flush</code>：刷新文件的函数，通常在关闭文件时调用。</li><li><code>llseek</code>：改变文件读写指针位置的函数。</li><li><code>fsync</code>：将文件数据同步写入磁盘的函数。</li><li><code>poll</code>：询问文件是否可被非阻塞读写</li></ul><h4 id="2-3-dev-t">2.3 dev_t</h4><p><strong>主要作用</strong>：表示字符设备对应的设备号，其中包括主设备号和次设备号。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u32 <span class="type">__kernel_dev_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">__kernel_dev_t</span>  <span class="type">dev_t</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="3、字符设备驱动整体架构">3、字符设备驱动整体架构</h3><h4 id="3-1-加载与卸载函数">3.1 加载与卸载函数</h4><p>驱动首先实现的就是加载和卸载函数，也是驱动程序的入口函数。</p><p>我们一般这么定义驱动的加载卸载函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br></pre></td></tr></table></figure><p>这段代码就是实现一个通用驱动的加载与卸载，关于<code>module_init</code>和<code>module_exit</code>的实现机制，可以查看之前总结文章。</p><h4 id="3-2-设备号管理">3.2 设备号管理</h4><h5 id="3-2-1-设备号的概念">3.2.1 设备号的概念</h5><p>每一类字符设备都有一个唯一的设备号，其中设备号又分为主设备号和次设备号，那么这两个分别作用是什么呢？</p><ul><li>主设备号：用于标识设备的类型，</li><li>次设备号：用于区分同类型的不同设备</li></ul><h5 id="3-2-2-设备号的分配">3.2.2 设备号的分配</h5><p>设备号的分配方式有静态分配，动态分配：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态分配</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态分配</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>; </span><br></pre></td></tr></table></figure><p>也可以使用：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// major设为0时，就由内核动态分配，否则静态分配</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span>;</span><br></pre></td></tr></table></figure><p>在<code>Linux</code>中，我们可以通过<code>cat /proc/devices</code>命令，查看所有i登记的设备号列表。</p><h5 id="3-2-3-设备号的注销">3.2.3 设备号的注销</h5><p>设备号作为一种系统资源，当所对应的设备卸载时，当然也要将其所占用的设备号归还给系统。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注销也有不同的api，这里展示一种</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>major</code>：主设备号</li><li><code>name</code>：设备号名字</li></ul><h5 id="3-2-4-设备号的获取">3.2.4 设备号的获取</h5><p>设备号的管理很简单，在关键数据结构中，我们看到设备号的类型是<code>dev_t</code>，也就是<code>u32</code>类型表示的一个数值。</p><p>其中主设备号和次设备号的分界线，由<code>MINORBITS</code>宏定义指定：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINORBITS 20</span></span><br></pre></td></tr></table></figure><p>也就是主设备号占用高<code>12bit</code>，次设备号占用低<code>20bit</code></p><p>并且，内核还提供了相关<code>API</code>接口，来获取主设备号和次设备号，以及生成设备号的接口，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINORMASK ((1U &lt;&lt; MINORBITS) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR(dev) ((unsigned int) ((dev) &gt;&gt; MINORBITS))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINOR(dev) ((unsigned int) ((dev) &amp; MINORMASK))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKDEV(ma,mi) (((ma) &lt;&lt; MINORBITS) | (mi)) <span class="comment">// 用于将主设备号和次设备号组合成一个 dev_t 类型的设备号。</span></span></span><br></pre></td></tr></table></figure><blockquote><p>以上，通过移位操作，来实现主次设备号的获取。</p></blockquote><h5 id="3-2-4-通用代码实现">3.2.4 通用代码实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CUSTOM_DEVICE_NUM 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NUM 1</span></span><br><span class="line"><span class="meta">#device DEVICE_NAME <span class="string">&quot;XXXXXX&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> global_custom_major = CUSTOM_DEVICE_NUM;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dev_t</span> custom_device_number= MKDEV(global_custom_major, <span class="number">0</span>); <span class="comment">// custom device number</span></span><br><span class="line">    <span class="comment">/* device number register*/</span></span><br><span class="line">    <span class="keyword">if</span> (global_custom_major) &#123;</span><br><span class="line">        ret = register_chrdev_region(custom_device_number, DEVICE_NUM, DEVICE_NAME);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = alloc_chrdev_region(&amp;custom_device_number, <span class="number">0</span>, DEVICE_NUM, DEVICE_NAME);</span><br><span class="line">        global_custom_major = MAJOR(custom_device_number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_chrdev_region(MKDEV(global_mem_major, <span class="number">0</span>), DEVICE_NUM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br></pre></td></tr></table></figure><p>该函数实现了设备号的分配，如果主设备号为<code>0</code>，则采用动态配分的方式，否则采用静态分配的方式。</p><h4 id="3-3-字符设备的管理">3.3 字符设备的管理</h4><p>了解完设备号的管理之后，我们来看下字符设备是如何管理的。</p><h5 id="3-3-1、字符设备初始化">3.3.1、字符设备初始化</h5><p><strong>函数作用</strong>：初始化一个字符设备，并且将所对应的文件处理指针与字符设备绑定起来。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span>;</span><br></pre></td></tr></table></figure><h5 id="3-3-2、字符设备注册">3.3.2、字符设备注册</h5><p><strong>函数作用</strong>：添加一个字符设备驱动到<code>Linux</code>系统中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">p：一个字符设备指针，指向待添加的字符设备对象; </span></span><br><span class="line"><span class="comment">dev：该字符设备所负责的第一个设备编号</span></span><br><span class="line"><span class="comment">count：该类型设备的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="3-3-3、字符设备注销">3.3.3、字符设备注销</h5><p><strong>函数作用</strong>：从系统中移除该字符设备驱动</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>重要！！！！！！！！！！！！！！！！</p><p>不要混淆<code>register_chrdev</code>、<code>cdev_init</code>、<code>cdev_add</code>、 <code>class_create</code>、<code>device_create</code>这几个函数！！</p><ul><li><p><code>register_chrdev</code>只是用来分配设备号资源。</p></li><li><p><code>cdev_init</code>、 <code>cdev_add</code>， <code>cdev_del</code> 都是为了将字符设备注册进内核，管理字符设备对象。</p></li><li><p><code> class_create</code>、<code>device_create </code>用于在 <code>/dev</code> 目录下创建设备节点，使得用户空间能够访问到已注册的字符设备。</p></li></ul><p><strong>也就是说我可以用<code>cdev_init</code> 和 <code>cdev_add</code> 将字符设备注册进内核，但是我在用户空间还是看不到这个设备，只有用了 <code>device_create</code> 才能看到</strong>。</p></blockquote><h4 id="3-4-文件操作接口的实现">3.4 文件操作接口的实现</h4><p>因为在<code>Linux</code>中，一切皆文件的思想，所以每一个字符设备，也都有一个文件节点来对应。</p><p>我们在初始化字符设备的时候，会将<code>struct file_operations</code>的对象与字符设备进行绑定，其作用是来处理该字符设备的<code>open</code>、<code>read</code>、<code>write</code>等操作。</p><p>我们要做的就是去实现我们需要的函数接口，如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">global_mem_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .llseek = global_mem_llseek,</span><br><span class="line">    .read = global_mem_read,</span><br><span class="line">    .write = global_mem_write,</span><br><span class="line">    .unlocked_ioctl = global_mem_ioctl,</span><br><span class="line">    .open = global_mem_open,</span><br><span class="line">    .release = global_mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此，我们一个基本的字符设备驱动程序的框架就基本了然于胸了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式交叉编译环境和工具的使用</title>
      <link href="/2023/11/20/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%92%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/11/20/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%92%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="前言：">前言：</h4><ul><li>在嵌入式系统开发中，目标平台的架构和主机平台的架构通常不同。交叉编译就是在一种架构上的计算机上生成另一种架构上运行的代码的过程。</li><li><strong>目的：</strong> 嵌入式系统资源有限，无法在目标平台上进行编译。因此，开发者在更强大的主机上使用交叉编译工具链，生成在目标平台上运行的可执行文件。</li></ul><h4 id="配置">配置</h4><h5 id="1-下载工具链">1. 下载工具链</h5><h5 id="2-配置环境变量">2. 配置环境变量</h5><p>打开<code>~/.bashrc</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-buildroot-linux-gnueabihf-</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/.../arm-buildroot-linux-gnueabihf_sdk-buildroot/bin</span><br></pre></td></tr></table></figure><blockquote><p>不是所有的交叉编译器包都包含了库和头文件，如果不包含的话记得要另外进行配置。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uboot浅析</title>
      <link href="/2023/11/19/uboot%E6%B5%85%E6%9E%90/"/>
      <url>/2023/11/19/uboot%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是bootloader">1. 什么是bootloader ?</h3><p>Linux系统要启动就必须需要一个 <code>bootloader</code> 程序，也就说芯片上电以后先运行一段<code>bootloader</code> 程序。这段 <code>bootloader</code> 程序会先**初始化时钟，看门狗，中断，SDRAM，等外设，然后将 Linux内核从flash (NAND,NOR FLASH,SD,MMC等)拷贝到SDRAM中，最后启动Linux内核。**当然了bootloader的实际工作要复杂的多，但是它最主要的工作就是启动 Linux内核。</p><p><code>bootloader</code>和 Linux内核的关系就跟PC上的BIOS和 Windows的关系一样，bootloader就相当于BIOS。<strong>总得来说，Bootloader就是一小段程序，它在系统上电时开始执行，初始化硬件设备、准备好软件环境，最后调用操作系统内核</strong></p><img src="image-20231214112922892.png" alt="image-20231214112922892" style="zoom: 50%;" /><hr><h3 id="2-uboot启动过程中做了那些事">2. uboot启动过程中做了那些事 ?</h3><ol><li><h4 id="初始化阶段：">初始化阶段：</h4><ul><li><strong>时钟初始化：</strong> 设置系统时钟，确保系统能够以正确的时钟频率运行。</li><li><strong>关闭看门狗：</strong> 避免看门狗定时器引起系统复位。</li><li><strong>关闭中断：</strong> 在初始化阶段，通常会关闭中断，以防止中断干扰初始化过程。</li><li><strong>启动ICACHE：</strong> 如果存在指令缓存（Instruction Cache），则启动它以提高指令访问速度。</li><li><strong>关闭DCACHE和TLB：</strong> 关闭数据缓存（Data Cache）和转换后备缓冲（Translation Lookaside Buffer）。</li><li><strong>关闭MMU：</strong> 关闭内存管理单元，以确保物理地址和虚拟地址相等。</li><li><strong>SDRAM和NAND FLASH初始化：</strong> 初始化系统的主存储器，可能是SDRAM或NAND Flash，使其准备好接收和发送数据。</li><li><strong>重定位：</strong> 将uBoot从加载地址（通常是Flash的起始地址）重定位到RAM中的合适位置，以便后续执行。</li></ul></li><li><p><strong>初始化串口和检测系统内存：</strong></p><ul><li><strong>初始化串口：</strong> 配置并初始化一个或多个串口，以便在后续的启动过程中可以进行调试和输出信息。</li><li><strong>检测系统内存：</strong> 系统可能有多个设备，uBoot在这一阶段会尝试检测和配置系统中的内存。</li></ul></li></ol><hr><h3 id="3-uboot和内核如何完成参数传递">3. uboot和内核如何完成参数传递 ?</h3><p>uboot启动后已经完成了基本的硬件初始化(如:内存、串口等)，接下来，它的主要任务就是加载Linux内核到开发板的内存，然后跳转到Linux内核所在的地址运行。</p><p>具体是如何跳转呢 ? 做法很简单，<strong>直接修改PC寄存器的值为Linux内核所在的地址</strong>，这样CPU就会从Linux内核所在的地址去取指令，从而执行内核代码。在前面我们已经知道，在跳转到内核以前，uboot需要做好以下三件事情：</p><h4 id="1-CPU寄存器的设置">1). CPU寄存器的设置</h4><p>R0用于传递一个指向启动参数的指针，该指针包含了一系列的启动参数；</p><p>R1=机器类型 ID；对于ARM结构的CPU，其机器类型ID可以参见 linux/arch/arm tools/ mach-types</p><p>R2=启动参数标记列表在RAM中起始基地址</p><h4 id="2-CPU工作模式">2). CPU工作模式</h4><p>必须禁止中断 (IRQs和FIQs )</p><p>CPU必须为SVC模式</p><blockquote><p>SVC（Supervisor Call）模式是ARM体系结构中的一种特权级别，通常用于操作系统内核运行时。</p><p>在SVC模式下，处理器处于特权级别最高的状态，具有对所有资源的完全控制权，包括对系统寄存器和内存的访问。</p></blockquote><h4 id="3-Cache和MMU的设置">3). Cache和MMU的设置</h4><p>MMU必须关闭</p><p>指令 Cache 可以打开也可以关闭</p><p>数据 Cache 必须关闭</p><p>其中上面第一步CPU寄存器的设置中，就是通过R0,R1,R2三个参数给内核传递参数的。</p><hr><h3 id="4-为什么要给内核传递参数呢">4. 为什么要给内核传递参数呢 ?</h3><p>在此之前，uboot已经完成了硬件的初始化，可以说已经”适应了“这块开发板。然而，内核并不是对于所有的开发板都能完美适配的(如果适配了，可想而知这个内核有多庞大，又或者有新技术发明了，可以完美的适配各种开发板)，此时，对于开发板的环境一无所知。所以，要想启动Linux内核，uboot必须要给内核传递一些必要的信息来告诉内核<strong>当前所处的环境。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB常用指令</title>
      <link href="/2023/11/18/GDB%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/11/18/GDB%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<ul><li><p>GDB（GNU Debugger）是一个强大的调试器，用于调试程序并查找代码中的错误。它支持多种编程语言，包括C、C++、Fortran等。</p></li><li><p><strong>使用GDB之前，必须加上编译选项 <code>-g</code></strong></p></li><li><p>以下是一些 GDB 的常用指令：</p></li></ul><h4 id="启动-GDB：">启动 GDB：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb [可执行文件]</span><br></pre></td></tr></table></figure><h4 id="运行程序：">运行程序：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run [命令行参数]</span><br></pre></td></tr></table></figure><h4 id="设置断点：">设置断点：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">break</span> [文件名:行号]  <span class="comment"># 在指定行设置断点</span></span><br><span class="line"><span class="built_in">break</span> [函数名]      <span class="comment"># 在指定函数设置断点</span></span><br></pre></td></tr></table></figure><h4 id="查看断点列表：">查看断点列表：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">info breakpoints</span><br></pre></td></tr></table></figure><h4 id="删除断点：">删除断点：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">delete [断点编号]</span><br></pre></td></tr></table></figure><h4 id="继续执行程序：">继续执行程序：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure><h4 id="单步执行：">单步执行：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">step  <span class="comment"># 进入函数</span></span><br><span class="line">next  <span class="comment"># 单步执行，不进入函数</span></span><br></pre></td></tr></table></figure><h4 id="查看变量的值：">查看变量的值：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> [变量名]</span><br></pre></td></tr></table></figure><h4 id="显示堆栈信息：">显示堆栈信息：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">backtrace</span><br></pre></td></tr></table></figure><h4 id="切换到另一个帧：">切换到另一个帧：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frame [帧号]</span><br></pre></td></tr></table></figure><h4 id="查看寄存器的值：">查看寄存器的值：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">info registers</span><br></pre></td></tr></table></figure><h4 id="查看内存内容：">查看内存内容：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x/[格式] [地址]</span><br></pre></td></tr></table></figure><h4 id="设置观察点：">设置观察点：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch [表达式]</span><br></pre></td></tr></table></figure><h4 id="查看源代码：">查看源代码：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list [行号]  <span class="comment"># 显示当前位置前后的源代码</span></span><br></pre></td></tr></table></figure><h4 id="退出-GDB：">退出 GDB：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure><p>这只是 GDB 的一小部分功能和常用指令。在实际使用中，可以通过 <code>help</code> 命令在 GDB 中查看更多的指令帮助，例如 <code>help break</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程管理系统调用</title>
      <link href="/2023/11/18/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
      <url>/2023/11/18/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>来源《Unix/Linux系统编程》一书</p><h3 id="进程创建">进程创建</h3><h4 id="fork">fork()</h4><p>用法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br></pre></td></tr></table></figure><ul><li><code>fork()</code> 调用会创建一个当前进程的副本，其中父进程和子进程拥有相同的代码、数据、文件描述符等，但是具有不同的进程标识号（PID）。</li></ul><p>下面是一个简单的例子，演示如何使用 <code>fork()</code> 创建进程：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 fork() 创建新进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process: PID=%d\n&quot;</span>, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程代码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process: PID=%d, Child PID=%d\n&quot;</span>, getpid(), pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父子进程都会执行以下代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is common code. PID=%d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，**<code>fork()</code> 返回两次：在父进程中返回子进程的PID，而在子进程中返回0。**因此，通过检查 <code>fork()</code> 的返回值，可以在父子进程中执行不同的代码逻辑。</p><p>请注意，<code>fork()</code> 会复制当前进程的地址空间，包括代码、数据等，因此父子进程会执行相同的程序。</p><h4 id="exec系列">exec系列</h4><p>如果需要在子进程中执行不同的程序，可以使用 <code>exec</code> 系列的系统调用，例如 <code>execvp()</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 在子进程中执行新程序</span></span><br><span class="line">        <span class="type">char</span> *args[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">        execvp(<span class="string">&quot;ls&quot;</span>, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// execvp() 执行失败才会执行到这里</span></span><br><span class="line">        perror(<span class="string">&quot;execvp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process: PID=%d, Child PID=%d\n&quot;</span>, getpid(), pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，子进程使用 <code>execvp()</code> 执行了新的程序（<code>ls -l</code>），而父进程继续执行原来的程序。</p><hr><h3 id="进程终止">进程终止</h3><h4 id="正常终止：exit">正常终止：exit()</h4><p><code>exit()</code> ：这个调用会触发一系列清理操作，包括关闭文件描述符、释放动态分配的内存等。进程的退出状态通过 <code>exit()</code> 的参数传递给操作系统。例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 正常终止并返回退出状态码 0</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常终止：">异常终止：</h4><p>进程也可以因为某些<strong>异常</strong>情况而终止，例如执行了非法指令、访问了无效的内存等。</p><hr><h3 id="等待子进程终止-wait">等待子进程终止: wait()</h3><p><code>wait</code> 是一个系统调用，用于父进程等待其子进程的终止。这个调用允许父进程在子进程退出后获取有关子进程终止状态的信息。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pid = wait(<span class="type">int</span> *status);</span><br></pre></td></tr></table></figure><p>在C语言中，可以使用 <code>wait</code> 函数来实现等待子进程的终止。以下是一个简单的例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process: PID=%d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 子进程正常终止</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">42</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程代码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process: PID=%d, Child PID=%d\n&quot;</span>, getpid(), pid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待子进程终止</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="type">pid_t</span> child_pid = wait(&amp;status);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="comment">// 子进程正常终止</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child process %d exited with status %d\n&quot;</span>, child_pid, WEXITSTATUS(status));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">            <span class="comment">// 子进程因信号终止</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child process %d terminated by signal %d\n&quot;</span>, child_pid, WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，父进程通过 <code>wait</code> 等待子进程的终止。<code>wait</code> 返回子进程的PID，同时获取子进程的终止状态。通过 <code>WIFEXITED</code> 和 <code>WEXITSTATUS</code> 可以判断子进程是否正常终止，并获取退出状态码。这样，父进程就可以在子进程终止后获取相应的信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备树浅析</title>
      <link href="/2023/11/17/%E8%AE%BE%E5%A4%87%E6%A0%91%E6%B5%85%E6%9E%90/"/>
      <url>/2023/11/17/%E8%AE%BE%E5%A4%87%E6%A0%91%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍">介绍</h3><p>设备树（Device Tree）是一种描述硬件设备信息的数据结构，它独立于具体的硬件架构和操作系统，为系统中的硬件组件提供了统一的描述方式。</p><h3 id="DTS、-DTC和DTB的关系">DTS、 DTC和DTB的关系</h3><ul><li>(1) DTS（device tree source）：.dts文件是设备树的源文件。由于一个SoC可能对应多个设备，这些.dst文件可能包含很多共同的部分，共同的部分一般被提炼为一个 .dtsi 文件，这个文件相当于C语言的头文件。</li><li>(2) DTC：DTC是将.dts编译为.dtb的工具，相当于gcc。</li><li>(3) DTB：编译后的二进制格式的设备树文件，它可以被linux内核解析。</li></ul><h3 id="DTS语法">DTS语法</h3><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>/</td><td>根节点</td></tr><tr><td>@</td><td>如果设备有地址，则由此符号指定</td></tr><tr><td>&amp;</td><td>引用节点</td></tr><tr><td>：</td><td>冒号前的label是为了方便引用给节点起的别名，此label一般使用为&amp;label</td></tr><tr><td>，</td><td>属性名称中可以包含逗号。如compatible属性的名字 组成方式为”[manufacturer], [model]”，加入厂商名是为了避免重名。自定义属性名中通常也要有厂商名，并以逗号分隔。</td></tr><tr><td>#</td><td>#并不表示注释。如 #address-cells ，#size-cells 用来决定reg属性的格式</td></tr><tr><td></td><td>空属性并不一定表示没有赋值。如 interrupt-controller 一个空属性用来声明这个node接收中断信号数据类型</td></tr><tr><td>””</td><td>引号中的为字符串，字符串数组：”strint1”,”string2”,”string3”</td></tr><tr><td>&lt; &gt;</td><td>尖括号中的为32位整形数字，整形数组&lt;12 3 4&gt;</td></tr><tr><td>[ ]</td><td>方括号中的为32位十六进制数，十六机制数据[0x11 0x12 0x13] 其中0x可省略</td></tr></tbody></table><h3 id="设备节点的标准属性">设备节点的标准属性</h3><h4 id="compatible-属性">compatible 属性</h4><ul><li>指定节点所代表的设备类型，用于将设备和驱动绑定起来</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">compatible = <span class="string">&quot;fsl,mpc8641&quot;</span>, <span class="string">&quot;ns16550&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="model-属性">model 属性</h4><ul><li>描述设备模块信息，比如名字什么的，例如：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">model = <span class="string">&quot;Samsung S3C2416 SoC&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="reg-属性">reg 属性</h4><ul><li>用于指定设备的地址范围或偏移。例如：一个设备有两个寄存器块，一个的地址是0x3000，占据32字节；另一个的地址是0xFE00，占据256字节，表示如下：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reg = &lt;<span class="number">0x3000</span> <span class="number">0x20</span> <span class="number">0xFE00</span> <span class="number">0x100</span>&gt;;</span><br></pre></td></tr></table></figure><h4 id="驱动匹配">驱动匹配</h4><p>Linux内核的设备树子系统会在启动时解析设备树，将设备信息传递给相应的设备驱动。设备树中的<code>compatible</code>属性用于与设备驱动进行匹配。</p><p>设备驱动中通常使用<code>of_match_table</code>结构指定设备树中的<code>compatible</code>属性与驱动匹配时的处理逻辑。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_device_of_match</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;my_device&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">/* Sentinel */</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(of, my_device_of_match);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_device_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_device&quot;</span>,</span><br><span class="line">        .of_match_table = my_device_of_match,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = my_device_probe,</span><br><span class="line">    .remove = my_device_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_platform_driver(my_device_driver);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孤儿进程、僵尸进程、守护进程</title>
      <link href="/2023/11/17/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/11/17/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>孤儿进程、僵尸进程和守护进程</strong>是与进程生命周期相关的概念。</p><h3 id="1-孤儿进程（Orphan-Process）：">1. 孤儿进程（Orphan Process）：</h3><ul><li><strong>定义：</strong> 孤儿进程是指其父进程退出或被终止，但是它自己仍在运行的进程。</li><li><strong>特征：</strong><ul><li>孤儿进程会被 init 进程（PID为1的进程，通常是操作系统的第一个进程）接管。</li><li>当父进程退出时，孤儿进程的父进程会变为 init 进程。</li></ul></li><li><strong>原因：</strong><ul><li>孤儿进程的产生通常是父进程没有及时等待子进程的结束状态，导致子进程成为孤儿。</li></ul></li></ul><h3 id="2-僵尸进程（Zombie-Process）：">2. 僵尸进程（Zombie Process）：</h3><ul><li><strong>定义：</strong> 僵尸进程是指一个进程已经执行完毕，但其父进程尚未对其进行善后处理，即尚未调用 <code>wait</code> 或 <code>waitpid</code> 等系统调用来获取子进程的结束状态。</li><li><strong>特征：</strong><ul><li>僵尸进程在进程表中仍然存在，但已经没有可执行的代码。</li><li>僵尸进程的进程状态（Process Status）为 Z（表示僵尸）。</li></ul></li><li><strong>原因：</strong><ul><li>父进程没有及时回收子进程的结束状态，可能是因为父进程没有合适的等待子进程的机制。</li></ul></li></ul><h3 id="3-守护进程（Daemon-Process）：">3. 守护进程（Daemon Process）：</h3><ul><li><strong>定义：</strong> 守护进程是一种在后台运行的进程，通常独立于控制终端，并且通常用于执行一些系统任务或服务。</li><li><strong>特征：</strong><ul><li>守护进程通常在系统启动时启动，并且一直运行，直到系统关闭或手动停止。</li><li>守护进程通常与用户交互较少，没有控制终端。</li></ul></li><li><strong>用途：</strong><ul><li>守护进程常用于提供系统服务，如网络服务、日志服务等。</li><li>守护进程经常以超级用户（root）的身份运行。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信</title>
      <link href="/2023/11/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/11/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="常见的通信方式">常见的通信方式</h4><h5 id="1-管道（Pipe）">1. 管道（Pipe）</h5><p>管道是一种半双工的通信方式，允许一个进程向另一个进程发送数据。</p><p>通常用于具有亲缘关系的进程之间通信，如父子进程。有两种类型：匿名管道和命名管道。</p><h5 id="2-消息队列（Message-Queue）">2. 消息队列（Message Queue）</h5><p>消息队列是一种通过消息进行通信的机制，允许一个进程向队列发送消息，另一个进程从队列中接收消息。</p><p>具备一定的消息缓冲区，允许异步通信。消息可以具有不同的优先级。</p><h5 id="3-共享内存（Shared-Memory）">3. 共享内存（Shared Memory）</h5><p>共享内存是一种允许两个或多个进程共享同一块物理内存的通信方式。</p><p>由于进程共享同一块内存，因此通信速度较快。但需要通过信号、互斥锁等机制进行同步。</p><h5 id="4-信号（Signal）">4. 信号（Signal）</h5><p>信号是一种异步通信机制，用于通知进程某个事件已发生。</p><p>可以用于进程之间的简单通信，如通知进程处理某个事件。</p><h5 id="5-套接字（Socket）">5. 套接字（Socket）</h5><p>套接字是一种网络编程中常见的通信方式，也可以用于不同进程间的通信。</p><p>可以在同一台机器上的不同进程之间通信，也可以在不同机器上的进程之间通信。</p><h5 id="6-文件映射（Memory-mapped-File）">6. 文件映射（Memory-mapped File）</h5><p>文件映射是将一个文件或者其他对象映射到进程的地址空间，实现共享。</p><p>进程可以直接读写映射的文件，实现进程间共享数据。</p><h5 id="7-信号量（Semaphore）">7. 信号量（Semaphore）</h5><p>信号量是一种用于进程间同步的机制，可以用于控制多个进程对共享资源的访问。</p><p>通过对信号量的操作，可以实现进程间的同步和互斥。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程vs线程</title>
      <link href="/2023/11/15/%E8%BF%9B%E7%A8%8Bvs%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/11/15/%E8%BF%9B%E7%A8%8Bvs%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="进程和线程的定义">进程和线程的定义</h4><h5 id="进程">进程</h5><p>进程是操作系统<strong>分配资源的基本单位</strong>，是程序在执行过程中的一个实例。</p><h5 id="线程">线程</h5><p>线程是进程中的一个独立执行单元，是<strong>程序执行的最小单位</strong>。一个进程可以包含多个线程，它们共享进程的资源，但有各自的执行序列。</p><hr><h4 id="进程和线程的定义-v2">进程和线程的定义</h4><h5 id="进程-v2">进程</h5><ul><li><p><strong>资源拥有</strong>：进程有自己的<strong>独立地址空间</strong>。每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。进程间通信需要通过进程间通信（IPC）机制。</p></li><li><p><strong>切换开销</strong>：进程切换的开销相对较大，因为它需要保存和恢复整个进程的上下文。</p></li><li><p><strong>独立性</strong>：进程是相互独立的，一个进程的崩溃通常不会影响其他进程。</p></li><li><p><strong>适用场景</strong>：适用于多个独立任务的并发执行，进程提供更强的隔离性。</p></li></ul><h5 id="线程-v2">线程</h5><ul><li><p><strong>资源拥有</strong>：而线程是<strong>共享进程中的数据</strong>，使用相同的地址空间因此，CPU切换一个线程的花费远比进程小很多，同时创建一个线程的开销也比进程小很多。</p></li><li><p><strong>切换开销</strong>：线程切换的开销相对较小，因为它们共享相同的地址空间，切换时只需要保存和恢复寄存器和栈等少量信息。</p></li><li><p><strong>独立性</strong>：线程是共享相同进程的资源的执行单元，一个线程的问题可能会影响到整个进程。</p></li><li><p><strong>适用场景</strong>：适用于在同一任务中需要并发执行的情况，线程共享相同的上下文，更容易实现通信。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核组成部分</title>
      <link href="/2023/11/15/Linux%E5%86%85%E6%A0%B8%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/"/>
      <url>/2023/11/15/Linux%E5%86%85%E6%A0%B8%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>如图所示，Linux 内核主要由**进程调度、内存管理、虚拟文件系统（VFS）、网络接口（NET）和进程间通信（IPC）**5个子系统组成。</p><p><img src="image-20231212193749133.png" alt="image-20231212193749133"></p><h4 id="1-进程调度">1. 进程调度</h4><p><strong>进程调度</strong>控制系统中的多个进程对 CPU 的访问，使得多个进程能在 CPU 中“微观串行，宏观并行”地执行。</p><p>进程调度处于系统的中心位置，内核中其他的子系统都依赖它，因为每个子系统都需要挂起或恢复进程</p><h4 id="2-内存管理">2. 内存管理</h4><p>内存管理的主要作用是控制多个进程安全地共享主内存区域。当 CPU 提供内存管理单元(MMU)时，Linux 内存管理对于每个进程完成从虚拟内存到物理内存的转换。</p><h4 id="3-虚拟文件系统">3. 虚拟文件系统</h4><p>如图 3.7 所示，Linux 虚拟文件系统隐藏了各种硬件的具体细节，为所有设备提供了统一的接口。而且，它独立于各个具体的文件系统，是对各种文件系统的一个抽象。它为上层的应用程序提供了统一的 <code>vfs_read()</code>、<code>vfs_write()</code>等接口，并调用具体底层文件系统或者设备驱动中实现的<code>file_operations </code>结构体的成员函数</p><p><img src="image-20231212194627207.png" alt="image-20231212194627207"></p><h4 id="4-网络接口">4. 网络接口</h4><p>网络接口提供了对各种网络标准的存取和各种网络硬件的支持。如图所示，在Linux中网络接口可分为网络协议和网络驱动程序，网络协议部分负责实现每一种可能的网络传输协议，网络设备驱动程序负责与硬件设备通信，每一种可能的硬件设备都有相应的设备驱动程序。</p><p><img src="image-20231212194737404.png" alt="image-20231212194737404"></p><h4 id="5-进程间通信">5. 进程间通信</h4><p>进程间通信支持进程之间的通信，Linux 支持进程间的多种通信机制，包含信号量、共享内存、消息队列、管道、UNIX 域套接字等，这些机制可协助多个进程、多资源的互斥访问、进程间的同步和消息传递。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐观锁vs悲观锁</title>
      <link href="/2023/11/14/%E4%B9%90%E8%A7%82%E9%94%81vs%E6%82%B2%E8%A7%82%E9%94%81/"/>
      <url>/2023/11/14/%E4%B9%90%E8%A7%82%E9%94%81vs%E6%82%B2%E8%A7%82%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p><strong>乐观锁</strong>和<strong>悲观锁</strong>是并发控制的两种不同策略，用于处理多线程或多进程环境中对共享资源的访问。它们的区别在于对资源的访问方式和对冲突的处理方式。</p><h3 id="1-乐观锁（Optimistic-Locking）：">1. 乐观锁（Optimistic Locking）：</h3><ul><li><strong>思想：</strong><ul><li>乐观锁的基本思想是假设在绝大多数情况下，冲突是不会发生的，因此在访问共享资源之前不会加锁。只有在更新时，才检查是否有冲突发生。</li></ul></li><li><strong>实现方式：</strong><ul><li>使用版本号或时间戳等机制，在读取数据的同时记录数据的版本信息。在更新数据时，检查版本号或时间戳，如果没有发生冲突，就更新数据并增加版本号。如果发生冲突，需要进行回滚或重新尝试。</li></ul></li><li><strong>优势：</strong><ul><li>适用于读多写少的场景，减少了锁的使用，提高了并发性能。</li></ul></li></ul><h3 id="2-悲观锁（Pessimistic-Locking）：">2. 悲观锁（Pessimistic Locking）：</h3><ul><li><strong>思想：</strong><ul><li>悲观锁的基本思想是假设在并发环境中总会发生冲突，因此在访问共享资源之前先加锁，确保只有一个线程能够访问。</li></ul></li><li><strong>实现方式：</strong><ul><li>使用传统的互斥锁（例如，Mutex或Semaphore）来保护共享资源，一次只允许一个线程访问。其他线程必须等待锁的释放。</li></ul></li><li><strong>优势：</strong><ul><li>适用于写多读少的场景，确保数据的一致性，但在高并发环境下可能导致性能下降。</li></ul></li></ul><h3 id="总结：">总结：</h3><ul><li><strong>选择策略：</strong><ul><li>选择乐观锁还是悲观锁通常取决于应用的性质和并发访问的模式。在一些情况下，两者也可以结合使用。</li></ul></li><li><strong>实现复杂度：</strong><ul><li>乐观锁的实现相对较复杂，需要额外的版本号或时间戳等信息；而悲观锁相对直观，但在高并发情况下可能引起性能问题。</li></ul></li><li><strong>适用场景：</strong><ul><li>乐观锁适用于读多写少的场景，而悲观锁适用于写多读少的场景。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原子操作与CAS浅析</title>
      <link href="/2023/11/14/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8ECAS%E6%B5%85%E6%9E%90/"/>
      <url>/2023/11/14/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8ECAS%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="原子操作">原子操作</h3><p>**原子操作是指不会被线程调度机制打断的操作，保证共享资源访问是唯一的；**这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）</p><p>一般原子操作需要CPU等硬件支持，使用硬件<strong>同步原语</strong>来实现原子操作。常用的原语有<code>CAS（compare-and-swap）</code>、<code>TES（test-and-set）</code>、<code>FAA（fetch-and-add）</code></p><h3 id="CAS">CAS</h3><p>CAS(Compare and Swap) 是并发编程中常用的一种同步原语，CAS操作是通过比较内存中的值和一个预期值，如果相等，则将一个新值存入内存中。整个操作是原子的，不会被其他线程中断。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux查找ip的几种方式</title>
      <link href="/2023/11/13/Linux%E6%9F%A5%E6%89%BEip%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/11/13/Linux%E6%9F%A5%E6%89%BEip%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="1-ifconfig-命令：">1. <strong>ifconfig 命令：</strong></h3><ul><li><code>ifconfig</code> 命令用于显示和配置网络接口的信息，包括IP地址。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><h3 id="2-ip-命令：">2. <strong>ip 命令：</strong></h3><ul><li><code>ip</code> 命令是更现代化的网络配置工具，也可以用于查看IP地址。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip address</span><br></pre></td></tr></table></figure><h3 id="3-hostname-命令：">3. <strong>hostname 命令：</strong></h3><ul><li><code>hostname</code> 命令用于显示主机名和相应的IP地址。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostname -I</span><br></pre></td></tr></table></figure><h3 id="4-ping-命令：">4. <strong>ping 命令：</strong></h3><ul><li><code>ping</code> 命令可以用于测试网络连通性，同时也会显示目标主机的IP地址。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping example.com</span><br></pre></td></tr></table></figure><h3 id="5-traceroute-命令：">5. <strong>traceroute 命令：</strong></h3><ul><li><code>traceroute</code> 命令用于跟踪数据包的路由路径，显示经过的路由器和目标主机的IP地址。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">traceroute example.com</span><br></pre></td></tr></table></figure><h3 id="6-dig-命令：">6. <strong>dig 命令：</strong></h3><ul><li><code>dig</code> 命令用于查询DNS信息，包括主机名对应的IP地址。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig example.com</span><br></pre></td></tr></table></figure><h3 id="7-nslookup-命令：">7. <strong>nslookup 命令：</strong></h3><ul><li><code>nslookup</code> 命令也用于查询DNS信息，可以查询主机名的IP地址。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nslookup example.com</span><br></pre></td></tr></table></figure><h3 id="8-cat-etc-hosts-文件：">8. <strong>cat /etc/hosts 文件：</strong></h3><ul><li><code>/etc/hosts</code> 文件包含主机名与IP地址的映射关系，可以直接查看该文件。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/hosts</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户态vs内核态</title>
      <link href="/2023/11/13/%E7%94%A8%E6%88%B7%E6%80%81vs%E5%86%85%E6%A0%B8%E6%80%81/"/>
      <url>/2023/11/13/%E7%94%A8%E6%88%B7%E6%80%81vs%E5%86%85%E6%A0%B8%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>用户态（User Mode）和内核态（Kernel Mode）是计算机操作系统中的两个不同的特权级别，用于<strong>控制程序对系统资源的访问和执行指令的权限</strong>。以下是它们的主要区别：</p><h3 id="用户态（User-Mode）：">用户态（User Mode）：</h3><ul><li><strong>权限：</strong><ul><li>在用户态，程序只能访问自己的内存空间和受限的系统资源，无法直接访问操作系统核心或硬件资源。</li></ul></li><li><strong>指令执行：</strong><ul><li>用户态程序执行普通指令，没有权限执行特权指令，例如修改页表、启动中断等。</li></ul></li><li><strong>中断和异常：</strong><ul><li>用户态程序可以触发中断和异常，但是处理这些中断和异常的代码运行在内核态。</li></ul></li></ul><h3 id="内核态（Kernel-Mode）：">内核态（Kernel Mode）：</h3><ul><li><strong>权限：</strong><ul><li>在内核态，操作系统核心拥有对系统硬件和资源的完全控制权，可以执行特权指令，访问系统关键数据结构和硬件寄存器。</li></ul></li><li><strong>指令执行：</strong><ul><li>内核态可以执行所有指令，包括特权指令，以执行对硬件和系统资源的底层控制。</li></ul></li><li><strong>中断和异常：</strong><ul><li>内核态可以处理所有中断和异常，并且可以直接访问和修改系统状态。</li></ul></li></ul><hr><h3 id="三种进入内核态的方式：">三种进入内核态的方式：</h3><ol><li>系统调用</li><li>中断</li><li>异常</li></ol><hr><h3 id="进入内核态并非进程为所欲为">进入内核态并非进程为所欲为</h3><p>尽管进入内核态赋予了程序更高的特权和更大的系统资源访问权限，但并不意味着进程可以为所欲为。</p><p>即使在内核态，<strong>进程也必须通过明确定义的接口（如系统调用）来与操作系统进行通信</strong>，而且操作系统会对这些请求进行审查和控制，以保护系统的完整性和安全性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP&#92;UDP详解</title>
      <link href="/2023/11/12/TCPUDP%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/11/12/TCPUDP%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="TCP">TCP</h3><img src="image-20231212113845207.png" alt="image-20231212113845207" style="zoom:80%;" /><h4 id="三次握手">三次握手</h4><ol><li><p><strong>第一步:  客户端发送SYN</strong></p><ul><li>Client将标志位SYN置为1，<strong>表示请求建立连接</strong>。</li><li>客户端还选择一个初始序列号（ISN），用于后续的数据传输。</li></ul></li><li><p><strong>第二步：服务器回应SYN-ACK</strong></p><ul><li>服务器收到客户端的SYN后，返回一个带有SYN和ACK标志位的TCP报文，<strong>表示接受连接请求</strong>，并确认客户端的初始序列号。</li><li>服务器也选择一个初始序列号，用于服务器到客户端的数据传输。</li></ul></li><li><p><strong>第三步：客户端发送ACK</strong></p><ul><li>客户端收到服务器的SYN-ACK后，向服务器发送一个带有ACK标志位的TCP报文，<strong>表示确认连接建立。</strong></li><li>此时，双方的连接已成功建立，可以开始进行数据传输。</li></ul></li></ol><h4 id="四次挥手">四次挥手</h4><ol><li><strong>第一步 - 客户端发送FIN：</strong><ul><li>客户端在数据传输完成后，发送一个带有FIN标志位的TCP报文，表示数据传输结束。</li></ul></li><li><strong>第二步 - 服务器回应ACK：</strong><ul><li>服务器收到客户端的FIN后，发送一个带有ACK标志位的TCP报文，确认收到客户端的关闭请求。</li></ul></li><li><strong>第三步 - 服务器发送FIN：</strong><ul><li>服务器在准备关闭连接时，发送一个带有FIN标志位的TCP报文，表示服务器也准备关闭连接。</li></ul></li><li><strong>第四步 - 客户端回应ACK：</strong><ul><li>客户端收到服务器的FIN后，发送一个带有ACK标志位的TCP报文，确认收到服务器的关闭请求。</li><li>此时，连接完全关闭，双方都进入CLOSED状态。</li></ul></li></ol><hr><h3 id="UDP">UDP</h3><ul><li>无连接：只知道对端的IP和端口号就可以发送，不需要实现建立连接。</li><li>不可靠：**没有确认机制， 没有重传机制。**如果因为网络故障该段无法发到对方， UDP协议层也不会给应用层返回任何错误信息。</li><li>面向数据报： 应用层交给UDP多长的报文， UDP原样发送既不会拆分，也不会合并。如果发送端调用一次<code>sendto</code>, 发送100个字节, 那么接收端也必须调用对应的一次<code>recvfrom</code>, 接收100个 字节，而不能循环调用10次<code>recvfrom</code>, 每次接收10个字节。<strong>所以UDP不能够灵活的控制读写数据的次数和数量。</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步、异步与阻塞、非阻塞的差异</title>
      <link href="/2023/11/11/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
      <url>/2023/11/11/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="同步与异步">同步与异步</h4><h5 id="同步">同步</h5><p>在同步操作中，一个任务的执行会等待另一个任务完成，这两个任务之间存在依赖关系。调用方会阻塞等待结果。</p><blockquote><p>同步通信的双方需要频率一致的时钟。（如IIC，SPI）</p></blockquote><h5 id="异步">异步</h5><p>在异步操作中，任务的执行不会等待另一个任务完成。调用方不会阻塞，而是继续执行其他任务。通常通过回调、Promise等机制来处理异步操作的结果。</p><blockquote><p>异步通信的双方使用各自的时钟（如UART）。</p></blockquote><hr><h4 id="阻塞和非阻塞">阻塞和非阻塞</h4><h5 id="阻塞">阻塞</h5><p>在一个任务执行的过程中，如果需要等待某个事件完成，那么整个任务就会阻塞，等待这个事件的完成。</p><h5 id="非阻塞">非阻塞</h5><p>在一个任务执行的过程中，如果遇到需要等待的事件，任务会继续执行而不是等待，通过轮询或回调等方式检查事件是否完成。</p><hr><h4 id="同步-阻塞">同步 != 阻塞</h4><h5 id="同步和阻塞">同步和阻塞</h5><p>同步操作可能导致阻塞，因为调用方需要等待操作完成。</p><h5 id="同步和非阻塞">同步和非阻塞</h5><p>同步操作也可以是非阻塞的，例如，在进行同步I/O操作时，调用方可以继续执行其他任务而不等待I/O的完成。</p><blockquote><p>考虑一个进行同步I/O操作的场景，如文件读取。在传统的同步I/O模型中，当进行文件读取时，程序会一直等待文件读取完成后再执行下一步操作，这是典型的阻塞操作。</p><p>但如果使用非阻塞的同步I/O模型，调用方可以发起文件读取请求，然后继续执行其他任务，而不必等待文件读取完成。在后续需要读取文件的数据时，程序可以检查文件读取操作是否完成，如果完成则获取数据，否则继续执行其他任务。这种方式允许程序在等待I/O完成的同时继续执行其他操作，提高了系统的并发性。</p></blockquote><p><strong>同步操作确保了任务的顺序性和可预测性。</strong></p><p><strong>阻塞操作中，程序会停滞等待直到某个条件满足。</strong></p><hr><h4 id="异步-非阻塞">异步 != 非阻塞</h4><h5 id="异步和阻塞：">异步和阻塞：</h5><p>异步操作可以是阻塞的，例如，在异步I/O操作中，调用方可以等待I/O的完成。</p><h5 id="异步和非阻塞：">异步和非阻塞：</h5><p>异步操作通常是非阻塞的，因为调用方不需要等待操作的完成，而是通过回调等方式处理操作完成的结果。</p><hr><h4 id="举个例子">举个例子</h4><p>老张爱喝茶，废话不说，煮开水。</p><p>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</p><ol><li>老张把水壶放到火上，立等水开。（同步阻塞）老张觉得自己有点傻。</li><li>老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）。</li><li>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。</li><li>老张把响水壶放到火上，立等水开。（异步阻塞）。</li><li>老张觉得这样傻等意义不大，老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）。</li></ol><ul><li>所谓同步异步，只是对于水壶而言。普通水壶，同步；响水壶，异步。虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</li><li>所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；看电视的老张，非阻塞。<br>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UART深入剖析</title>
      <link href="/2023/11/11/UART%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/"/>
      <url>/2023/11/11/UART%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="UART深入剖析">UART深入剖析</h3><p><strong>UART</strong>是一种串行、异步、全双工的通信协议。</p><p>UART由三根数据线构成：TXRXGND</p><ul><li><p>**空闲位：**空闲状态时信号线为高电平</p></li><li><p>**起始位：**发送方先发出低电平，表示传输字符的开始。</p></li><li><p><strong>数据位：<strong>起始位之后就是我们所要传输的数据，数据位可以是5、6、7、8，9位等，构成一个字符（一般都是8位）。先发送</strong>最低位</strong>，最后发送<strong>最高位</strong>。</p></li><li><p>**奇偶校验位：**数据位加上这一位，可以校验数据传送的正确性。</p></li><li><p>**停止位：**它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。</p></li></ul><p><img src="image-20231212102929836.png" alt="image-20231212102929836"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPI深入剖析</title>
      <link href="/2023/11/08/SPI/"/>
      <url>/2023/11/08/SPI/</url>
      
        <content type="html"><![CDATA[<h4 id=""></h4><h3 id="SPI深入剖析">SPI深入剖析</h3><ul><li><p>SPI是同步通信协议</p></li><li><p>SPI接口有4条数据线：SCKSSMOSI　MISO</p></li></ul><h4 id="SPI-通信流程"><strong>SPI 通信流程</strong></h4><p>主设备选通一个或多个从设备，将 SS 线拉低，以确定通信目标。</p><p>主设备通过 SCLK 线产生时钟信号，驱动数据在 MOSI 上发送给从设备。</p><p>从设备根据时钟信号，在 MISO 上将响应数据返回给主设备。</p><p>通信完成后，主设备将 SS 线拉高，释放从设备。</p><h4 id="时钟极性（CPOL）与时钟相位（CPHA）">时钟极性（CPOL）与时钟相位（CPHA）</h4><p>SPI通信可以配置为不同的时钟极性和相位。</p><p>时钟极性定义时钟在空闲状态时的电平</p><ul><li>如果CPOL= 0，串行同步时钟的空闲状态为低电平；</li><li>如果CPOL= 1，串行同步时钟的空闲状态为高电平。</li></ul><p>时钟相位定义数据采样的时机</p><ul><li><p>如果CPHA= 0，在串行同步时钟的第一个跳变沿（上升或下降）数据被采样；</p></li><li><p>如果CPHA = 1，在串行同步时钟的第二个跳变沿（上升或下降）数据被采样。</p></li></ul><p><img src="image-20231211102038775.png" alt="image-20231211102038775"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIC深入剖析</title>
      <link href="/2023/11/08/IIC/"/>
      <url>/2023/11/08/IIC/</url>
      
        <content type="html"><![CDATA[<h3 id="I2C总线与I2C通信协议的区别">I2C总线与I2C通信协议的区别</h3><ul><li><p><strong>I2C总线是硬件概念：</strong> I2C总线是<strong>物理连接设备的电缆和线路</strong>。它提供了设备之间进行串行通信的基础结构。</p></li><li><p><strong>I2C协议是通信规则：</strong> I2C协议定义了在I2C总线上设备之间如何进行<strong>通信的规则</strong>。它规定了数据的传输格式、起始和停止条件、时钟频率等。</p></li></ul><h3 id="IIC详解">IIC详解</h3><p>IIC是多主机的半双工同步通信协议，<strong>数据线SDA</strong>和<strong>时钟线SCL</strong>构成。</p><blockquote><ol><li>各设备连接到总线的输出端必须是<strong>开漏输出</strong>或集电极开路输出的结构</li><li>在任意时刻只能有一个主控</li></ol></blockquote><p>空闲状态，上拉电阻使SDA和SCL信号线同时处于高电平；</p><p>由于**”线与“**逻辑，I2C总线上任意器件输出低电平都会使相应总线上的信号线变低；</p><h4 id="开始位和停止位">开始位和停止位</h4><p>当SCL 稳定在高电平时，SDA 由高到低的变化将产生一个开始位，而由低到高的变化，则产生一个停止位。</p><p><img src="image-20231211210806975.png" alt="image-20231211210806975"></p><ul><li>开始位和停止位都由I2C 主设备产生。</li></ul><p>在选择从设备时，如果从设备采用7 位地址，则主设备在发起传输过程前，需先发送1 字节的地址信息，前7 位为设备地址，最后1 位为读写标志。之后，每次传输的数据也是1字节，从MSB 开始传输。</p><p>每个字节传完后，在SCL的第9个上升沿到来之前，接收方应该发出1个ACK 位。</p><blockquote><ol><li><p>SCL 上的时钟脉冲由I2C主控方发出</p></li><li><p>在第8个时钟周期之后，主控方应该释放<strong>SDA</strong>。(因为要让给从机响应ACK)</p></li></ol></blockquote><p><img src="image-20231211211114744.png" alt="image-20231211211114744"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Windows使用VSCode搭建嵌入式Linux开发环境</title>
      <link href="/2023/11/07/%E5%9C%A8Windows%E4%BD%BF%E7%94%A8VSCode%E6%90%AD%E5%BB%BA%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/11/07/%E5%9C%A8Windows%E4%BD%BF%E7%94%A8VSCode%E6%90%AD%E5%BB%BA%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/在Windows使用VSCode搭建嵌入式Linux开发环境.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实战1：led驱动</title>
      <link href="/2023/11/06/%E5%AE%9E%E6%88%981%EF%BC%9Aled%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/11/06/%E5%AE%9E%E6%88%981%EF%BC%9Aled%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="实战1：led驱动">实战1：led驱动</h3><blockquote><p>环境：</p><p>首先配置好bear make、clangd、compile_command.json等等插件和环境，在windows下用vscode来ssh链接到虚拟机；</p><p>在vscode创建workspace；</p><p>串口工具使用MobaXterm；</p></blockquote><h4 id="驱动程序"><strong>驱动程序</strong></h4><ol><li><h5 id="不知道加什么头文件？✅-复制内核代码其他设备驱动的头文件！">不知道加什么头文件？✅ <strong>复制内核代码其他设备驱动的头文件！</strong></h5></li></ol><ul><li>cd 至内核的设备驱动目录</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/.../Linux-4.9.88/drivers/char</span><br></pre></td></tr></table></figure><ul><li>用grep查找”register_chrdev“</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;register_chrdev&quot;</span> * -nwr// 星号表示所有目录</span><br></pre></td></tr></table></figure><p>找到如下文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ds1302.c:349:   if (register_chrdev(RTC_MAJOR_NR, ds1302_name, &amp;rtc_fops)) &#123;</span><br><span class="line">dsp56k.c:503:   if(register_chrdev(DSP56K_MAJOR, &quot;dsp56k&quot;, &amp;dsp56k_fops)) &#123;</span><br><span class="line">dtlk.c:338:     dtlk_major = register_chrdev(0, &quot;dtlk&quot;, &amp;dtlk_fops);</span><br><span class="line">ipmi/ipmi_devintf.c:950:        rv = register_chrdev(ipmi_major, DEVICE_NAME, &amp;ipmi_fops);</span><br><span class="line">lp.c:980:       if (register_chrdev (LP_MAJOR, &quot;lp&quot;, &amp;lp_fops)) &#123;</span><br><span class="line">mbcs.c:815:     rv = register_chrdev(mbcs_major, DEVICE_NAME, &amp;mbcs_ops);</span><br><span class="line">mem.c:898:      if (register_chrdev(MEM_MAJOR, &quot;mem&quot;, &amp;memory_fops))</span><br><span class="line">misc.c:290:     if (register_chrdev(MISC_MAJOR,&quot;misc&quot;,&amp;misc_fops))</span><br><span class="line">pcmcia/cm4040_cs.c:659: major = register_chrdev(0, DEVICE_NAME, &amp;reader_fops);</span><br><span class="line">pcmcia/cm4000_cs.c:1897:        major = register_chrdev(0, DEVICE_NAME, &amp;cm4000_fops);</span><br><span class="line">ppdev.c:851:    if (register_chrdev(PP_MAJOR, CHRDEV, &amp;pp_fops)) &#123;</span><br><span class="line">tb0219.c:301:   retval = register_chrdev(major, &quot;TB0219&quot;, &amp;tb0219_fops);</span><br><span class="line">tlclk.c:780:    ret = register_chrdev(tlclk_major, &quot;telco_clock&quot;, &amp;tlclk_fops);</span><br><span class="line">virtio_console.c:2047:  portdev-&gt;chr_major = register_chrdev(0, &quot;virtio-portsdev&quot;,</span><br></pre></td></tr></table></figure><p>找到一个合适的，进去复制头文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm-generic/errno-base.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm-generic/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm/uaccess.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li><h5 id="定义gpio引脚">定义gpio引脚</h5></li></ol><ul><li>注意：gpio引脚需要查imx6ull底板图来确认，根据查询找到<code>led</code>在<code>gpio5_3</code></li></ul><p>串口连接到单片机，查看gpio</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/kernel/debug/gpio</span><br></pre></td></tr></table></figure><p>得到如下输出：</p><p><img src="image-20231205173431102.png" alt="image-20231205173431102"></p><p>因此确认<code>gpio5_3</code>在 <code>131</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>&#123;</span></span><br><span class="line"><span class="type">int</span> gpio;</span><br><span class="line"><span class="type">int</span> irq;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> <span class="title">gpios</span>[2] =</span> &#123;</span><br><span class="line">    &#123;<span class="number">131</span>, <span class="number">0</span>, <span class="string">&quot;led0&quot;</span>&#125;,</span><br><span class="line"><span class="comment">//&#123;132, 0, &quot;led1&quot;&#125;,</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li><h5 id="完成入口函数等等，在此不赘述">完成入口函数等等，在此不赘述</h5></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 主设备号                                                                 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_class</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现对应的open/read/write等函数，填入file_operations结构体                   */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">gpio_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> tmp_buf[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="type">int</span> count = <span class="keyword">sizeof</span>(gpios)/<span class="keyword">sizeof</span>(gpios[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = copy_from_user(tmp_buf, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp_buf[<span class="number">0</span>] &gt;= count)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">tmp_buf[<span class="number">1</span>] = gpio_get_value(gpios[tmp_buf[<span class="number">0</span>]].gpio);</span><br><span class="line"></span><br><span class="line">err = copy_to_user(buf, tmp_buf, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">gpio_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ker_buf[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">err = copy_from_user(ker_buf, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ker_buf[<span class="number">0</span>] &gt;= <span class="keyword">sizeof</span>(gpios)/<span class="keyword">sizeof</span>(gpios[<span class="number">0</span>]))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">gpio_set_value(gpios[ker_buf[<span class="number">0</span>]].gpio, ker_buf[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义自己的file_operations结构体                                              */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.read    = gpio_drv_read,</span><br><span class="line">.write   = gpio_drv_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_drv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> count = <span class="keyword">sizeof</span>(gpios)/<span class="keyword">sizeof</span>(gpios[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">&#123;</span><br><span class="line">err = gpio_request(gpios[i].gpio, gpios[i].name);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;can&#x27;t not require gpio %s\n&quot;</span>, gpios[i].name);</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gpio_direction_output(gpios[i].gpio, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册file_operations */</span></span><br><span class="line">major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_led&quot;</span>, &amp;gpio_key_drv);  <span class="comment">/* /dev/gpio_desc */</span></span><br><span class="line"></span><br><span class="line">gpio_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_led_class&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(gpio_class)) &#123;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">unregister_chrdev(major, <span class="string">&quot;100ask_led_class&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(gpio_class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">device_create(gpio_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_led&quot;</span>); <span class="comment">/* /dev/100ask_gpio */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_drv_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> count = <span class="keyword">sizeof</span>(gpios)/<span class="keyword">sizeof</span>(gpios[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">device_destroy(gpio_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">class_destroy(gpio_class);</span><br><span class="line">unregister_chrdev(major, <span class="string">&quot;100ask_led&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">&#123;</span><br><span class="line">gpio_free(gpios[i].gpio);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */</span></span><br><span class="line"></span><br><span class="line">module_init(gpio_drv_init);</span><br><span class="line">module_exit(gpio_drv_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试程序"><strong>测试程序</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//int led_on(int which);</span></span><br><span class="line"><span class="comment">//int led_off(int which);</span></span><br><span class="line"><span class="comment">//int led_status(int which);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./led_test &lt;0|1|2|..&gt;  on </span></span><br><span class="line"><span class="comment"> * ./led_test &lt;0|1|2|..&gt;  off</span></span><br><span class="line"><span class="comment"> * ./led_test &lt;0|1|2|..&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 判断参数 */</span></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;0|1|2|...&gt; [on | off]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 打开文件 */</span></span><br><span class="line">fd = open(<span class="string">&quot;/dev/100ask_led&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;can not open file /dev/100ask_led\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* write */</span></span><br><span class="line">buf[<span class="number">0</span>] = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;on&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buf[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ret = write(fd, buf, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">buf[<span class="number">0</span>] = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">ret = read(fd, buf, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;led %d status is %s\n&quot;</span>, buf[<span class="number">0</span>], buf[<span class="number">1</span>] == <span class="number">0</span> ? <span class="string">&quot;on&quot;</span> : <span class="string">&quot;off&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><h5 id="写完后，更改Makefile，把led-dev-ko-和-test-drv复制到挂载目录下，在板子上插入模块。">写完后，更改Makefile，把led_dev.ko 和 test_drv复制到挂载目录下，在板子上插入模块。</h5></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod led_drv.ko</span><br></pre></td></tr></table></figure><p>–END；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户线程和内核线程区别</title>
      <link href="/2023/11/05/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/11/05/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="用户线程：">用户线程：</h3><ol><li><strong>创建和管理：</strong> 用户线程是由用户空间的应用程序创建和管理的。用户线程的创建、调度和销毁完全由用户程序的线程库（用户级线程库）负责，而不需要内核的干预。</li><li><strong>轻量级：</strong> 用户线程是轻量级的，它们的创建和上下文切换开销相对较小。因为这些线程的管理是在用户空间进行的，不需要内核介入。</li><li><strong>阻塞：</strong> 当用户线程中的一个线程被阻塞时，整个进程可能被阻塞，因为内核不了解和不管理用户线程的阻塞状态。</li><li><strong>调度：</strong> 用户线程的调度是由用户级线程库实现的，通常是基于协作式调度（cooperative scheduling）。这意味着一个用户线程在执行期间可以主动让出 CPU 控制权。</li><li><strong>无法利用多核：</strong> 由于用户线程的调度是在用户空间完成的，内核无法将不同的用户线程分配到不同的核上运行，因此用户线程不能充分利用多核处理器的优势。</li></ol><h3 id="内核线程：">内核线程：</h3><ol><li><strong>创建和管理：</strong> 内核线程是由操作系统内核创建和管理的。内核线程的创建和销毁由内核负责，而不需要用户空间的干预。</li><li><strong>重量级：</strong> 内核线程是相对重量级的，因为它们的创建和上下文切换涉及到内核的介入。这导致了相对较高的开销。</li><li><strong>阻塞：</strong> 当一个内核线程被阻塞时，通常只影响到该线程，而不会影响整个进程。其他内核线程仍然可以在系统中执行。</li><li><strong>调度：</strong> 内核线程的调度是由操作系统内核的调度器实现的，通常是基于抢占式调度（preemptive scheduling）。这意味着内核线程可以被强制剥夺 CPU 控制权。</li><li><strong>多核利用：</strong> 内核线程可以更好地利用多核处理器，因为内核可以将不同的内核线程分配给不同的核。</li></ol><h3 id="总结：">总结：</h3><ul><li>用户线程更轻量级，由用户程序自己的线程库管理，但在阻塞和调度方面有一些限制。</li><li>内核线程更重量级，由操作系统内核管理，提供更好的阻塞和调度支持，并且能够更好地利用多核处理器。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程上下文与中断上下文区别</title>
      <link href="/2023/11/05/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/11/05/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="1-上下文切换触发时机：">1. 上下文切换触发时机：</h4><ul><li><strong>进程上下文：</strong> 进程上下文是在内核中执行进程代码时的执行环境。它通常由系统调用、中断、异常或调度程序引起。在进程上下文中，内核代码运行在进程的地址空间中。</li><li><strong>中断上下文：</strong> 中断上下文是在响应硬件中断时执行的上下文。硬件中断可以来自外部设备或是软中断触发的。中断上下文执行的代码是内核中的中断服务程序。</li></ul><h4 id="2-实时性要求：">2. 实时性要求：</h4><ul><li><strong>进程上下文：</strong> 进程上下文不要求实时性，允许较长时间的执行。因为进程上下文的切换是由操作系统的调度器控制的，可以在较长的时间间隔内完成。</li><li><strong>中断上下文：</strong> 中断上下文通常需要满足实时性的要求，因为中断服务程序必须迅速响应硬件中断。中断上下文中执行的代码应该尽量保持简短和快速。</li></ul><h4 id="3-中断屏蔽：">3. 中断屏蔽：</h4><ul><li><strong>进程上下文：</strong> 进程上下文中，中断是可以被屏蔽的。这意味着在进程上下文中执行的代码可以选择屏蔽中断，以防止中断干扰。</li><li><strong>中断上下文：</strong> 中断上下文是在中断时执行的，中断是不能被屏蔽的。中断服务程序必须响应中断，并且中断服务程序执行期间其他中断是被屏蔽的，以防止嵌套中断。</li></ul><h4 id="4-执行环境：">4. 执行环境：</h4><ul><li><strong>进程上下文：</strong> 进程上下文中，内核代码可以访问用户空间的地址空间，执行用户空间和内核空间的代码。</li><li><strong>中断上下文：</strong> 中断上下文中，内核代码只能访问内核空间，不能执行用户空间的代码。</li></ul><h4 id="5-响应性：">5. 响应性：</h4><ul><li><strong>进程上下文：</strong> 进程上下文的切换可以由操作系统的调度器控制，因此响应性较低。进程上下文切换可能需要等待调度器的调度决策。</li><li><strong>中断上下文：</strong> 中断上下文是由硬件中断引起的，响应性较高。中断服务程序迅速响应中断，不需要等待调度器。</li></ul><h4 id="总结：">总结：</h4><ul><li>进程上下文用于执行较长时间的内核代码，对实时性要求较低。</li><li>中断上下文用于迅速响应硬件中断，对实时性有较高的要求。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中断编程</title>
      <link href="/2023/11/04/Linux%E4%B8%AD%E6%96%AD%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/11/04/Linux%E4%B8%AD%E6%96%AD%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="申请和释放中断">申请和释放中断</h4><p>在Linux设备驱动中，使用中断的设备需要<strong>申请</strong>和<strong>释放</strong>对应的中断。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请中断</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放irq</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure><h4 id="底半部机制">底半部机制</h4><p>Linux实现底半部的机制主要有tasklet、工作队列、软中断、线程化irq；</p><h5 id="tasklet">tasklet</h5><p>tasklet的执行上下文是软中断，执行时机通常是顶半部返回的时候。</p><blockquote><p>软中断的执行相对于硬中断而言，更加灵活、不需要严格的实时性，并且能够在内核中执行较长时间的任务。</p></blockquote><p>使用 <code>tasklet</code> 时，一般的流程是：</p><ol><li><p><strong>注册 <code>tasklet</code>：</strong> 在驱动程序初始化阶段，通过 <code>tasklet_init()</code> 函数初始化一个 <code>tasklet</code> 结构，并通过 <code>tasklet_init()</code> 函数将其注册到内核中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_tasklet_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行 tasklet 相关的处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在初始化阶段注册 tasklet</span></span><br><span class="line">tasklet_init(&amp;my_tasklet, my_tasklet_function, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>触发 <code>tasklet</code>：</strong> 当驱动程序需要执行与 <code>tasklet</code> 相关的工作时，调用 <code>tasklet_schedule()</code> 函数触发 <code>tasklet</code> 的执行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在需要的时候触发 tasklet 执行</span></span><br><span class="line">tasklet_schedule(&amp;my_tasklet);</span><br></pre></td></tr></table></figure></li><li><p><strong>处理函数执行：</strong> 当内核下一次进入软中断上下文时，内核会检查 <code>tasklet</code> 的状态，如果处于待运行状态，就执行与之关联的处理函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_interrupt_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理中断的逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发 tasklet 执行</span></span><br><span class="line">    tasklet_schedule(&amp;my_tasklet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>总体来说，<code>tasklet_schedule()</code> 的作用是标记一个 <code>tasklet</code> 为待运行状态，以便在适当的上下文中执行与之相关的处理函数。这有助于避免在中断上下文中执行耗时的操作，从而提高系统的响应性。</p><h5 id="工作队列">工作队列</h5><p>工作队列的使用方法和<code>tasklet</code>非常相似，但是工作队列的执行上下文是内核线程，因此可以调度和睡眠。</p><p>使用 <code>工作队列</code> 时，一般的流程是：</p><ol><li><p><strong>注册工作队列：</strong> 定义一个工作队列和底半部执行函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">my_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_work_function</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行工作队列中的任务</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化和调度：</strong> 通过调用 <code>INIT_WORK</code> 宏将工作结构和处理函数关联，并通过 <code>schedule_work</code> 或 <code>queue_work</code> 函数将工作结构插入工作队列，以便在后台执行相关处理函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INIT_WORK(&amp;my_work, my_work_function);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度工作队列执行</span></span><br><span class="line">schedule_work(&amp;my_work);</span><br></pre></td></tr></table></figure></li></ol><h5 id="软中断">软中断</h5><p>软中断(Softirq)也是一种传统的底半部处理机制，它的执行时机通常是顶半部返回的时候，tasklet是基于软中断实现的，因此也运行于软中断上下文。</p><h5 id="threaded-irq">threaded_irq</h5><p><code>threaded_irq</code> 函数是 Linux 内核中用于注册<strong>线程化中断处理程序（threaded interrupt handler）的函数。</strong></p><ol><li><strong>上下文执行环境：</strong> <code>threaded_irq</code> 注册的中断处理程序在线程上下文中执行。线程上下文是在进程上下文中执行的，不要求严格的实时性，因此可以执行较长时间的任务。</li><li><strong>处理程序类型：</strong> <code>threaded_irq</code> 注册的中断处理程序是一个线程化中断处理程序。这意味着它可以执行较长时间的任务，而不会阻塞中断线。</li><li><strong>不阻塞中断线：</strong> 当 <code>threaded_irq</code> 注册的中断处理程序正在执行时，不会阻塞同一中断线上的其他中断处理程序。这允许多个中断处理程序并发执行。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常与中断</title>
      <link href="/2023/11/03/%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD/"/>
      <url>/2023/11/03/%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h4 id="异常与中断的概念与处理流程">异常与中断的概念与处理流程</h4><p><img src="image-20231129164249697.png" alt="image-20231129164249697"></p><ol><li>中断源</li><li>中断控制器</li><li>CPU</li></ol><h4 id="异常与中断有何区别">异常与中断有何区别</h4><p><strong>异常</strong>：主要用于处理程序执行期间的错误</p><p><strong>中断</strong>：主要用于处理外部设备或其他处理器的事件通知（e.g. 硬件中断，定时器中断）</p><h4 id="arm对异常-中断-处理过程：">arm对异常(中断)处理过程：</h4><ol><li><p>初始化：</p><blockquote><ol><li>设置中断源</li><li>设置中断控制器</li><li>设置CPU总开关（使能中断）</li></ol></blockquote></li><li><p>执行其他程序</p></li><li><p>产生中断：比如按下按键 --&gt; 中断控制器 --&gt; CPU</p></li><li><p>CPU每执行完一条指令都会检查有无中断/异常产生</p></li><li><p>CPU发现由中断/异常产生，开始处理。</p><blockquote><p>对于不同的异常，跳去不同的地址执行程序。该地址只有一条跳转指令，跳去执行某个函数（地址），这个就是<strong>异常向量</strong>。</p><p>异常向量表包含了一组异常处理程序的入口地址，每个异常/中断对应一个地址。当中断发生时，处理器会从异常向量表中找到相应的地址并跳转到那里执行。</p></blockquote></li><li><p>跳转的函数执行：</p><blockquote><ol><li>保存现场：各种寄存器</li><li>处理异常/中断：分辨中断源，再调用不同的处理函数。</li><li>恢复现场</li></ol></blockquote></li></ol><blockquote><p><strong>注意：上面的3，4，5都是硬件做的。</strong></p></blockquote><h4 id="Linux中断程序架构">Linux中断程序架构</h4><p><strong>中断处理原则</strong></p><ol><li>中断不能嵌套</li><li>中断处理时间越快越好</li></ol><p>但是由于中断处理程序通常比较耗时，Linux将中断处理程序分别两个半部：<strong>上半部</strong>和<strong>下半部</strong></p><p><img src="image-20231130154431818.png" alt="image-20231130154431818"></p><ul><li><p>上半部用于完成尽量少的比较紧急的任务。<strong>（通常被设计为不可被新的中断打断）</strong></p><blockquote><p>通常只是简单读取寄存器的中断状态，并在清除中断标志位后进行“登记中断“的工作，”登记中断“意味着将底半部处理程序挂到该设备的底半部执行队列中去。</p></blockquote></li><li><p>底半部几乎做了中断处理程序的所有事情。<strong>（通常被设计为可以被新的中断打断）</strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奇奇怪怪的碎碎念</title>
      <link href="/2023/11/01/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2023/11/01/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1>2023年11月份的碎碎念</h1><h2 id="11月的第一个星期">11月的第一个星期</h2><p>emotion：😭😭😭😭😭</p><p>🎸起因：新裤子北海怪兽演唱，本来没打算抢票的我，总觉得都开到家门口了，不抢怪可惜的。</p><blockquote><p>起初不打算抢票的原因：</p><ol><li>感觉新裤子越来越流行化了，觉得朋克太土了。</li><li>总觉得开演唱会太不像摇滚乐做的事儿了，摇滚乐就应该好好呆在livehouse，</li></ol><p>改变心意的原因：</p><ol><li>前一天晚上看了月夏最后一集的演唱会，朋克虽然土，但真的好容易让人回荡起被琐碎日子磨平的情绪，不用思考，没有晦涩的歌词，没有刻意制造的深刻，没有对社会的苦大仇深与抨击。我在这总是能感到裸露的情绪，为自己还能感受世界而庆幸。</li><li>第二个原因就是距离真的太近了，离学校只有不到2km的距离。</li></ol></blockquote><p>🌸经过：下午四点突然收到新裤子演唱会放票的信息，点进去一看发现280、580、780、980的票都有，我当机立断就想起前一天晚上想到如果有票的话叫上FL哥，但是之前根本没录入他们的个人身份信息，买票的时候就需要重新录入，一通下来本来可以抢到280票的我，硬生生因为录入他们的信息花了太多时间，错过280的票。此时已经很冲动了，想要去看演唱会的心情达到峰值，简单询问了一下就买了580的票乘4！！！！</p><p>🌰结果：太贵了！！太亏了！！还不能退票！！退票要收20%的手续费！！搞的FL哥和章鱼哥莫名支出了一大笔钱，关键是原本是不想看的，就算想看也是最便宜的票，一下子就比原计划多花了三百块！！！而且其实大家都互相不认识，感觉会尴尬。</p><p>而且FL哥感觉没有很想去，这波是擅自给别人做决定了，本来是打算买280的票然后就请他看的，因为冲动买票的行为导致也请不起了。</p><p>😭 导致：emo了一下午，觉得自己做事情太冲动太冲动，太不成熟，以此为鉴，得出一些结论，希望以后能减少此类事情的发生：</p><p>🌏心得：</p><ol><li><strong>提前确定好买票人，不要临时更改</strong>。如果有临时想叫的人，先管好已经定下来的，再去问别人。</li><li>提前录入买票人信息和取票地址。</li><li>不一定要一起买，不用为了连座特地一起买票，<strong>没有抢到票一切都是徒劳的</strong>。</li><li>只买最便宜一档的票！没有了就不买！因为总会等到有人出的！！</li><li>面对突如其来的票，先管自己的，再去管别人的，不带来不必要的麻烦。</li></ol><p>将该抢票心得映射到其他的事情上：</p><ol><li>不要在心急的时候做决定！不要被突如其来的计划改变乱了阵脚！如果实在计划有变，考虑此事事关自己还是事关他人，</li><li><strong>如若事关他人</strong>，则不要轻易改变计划，别人不一定能接受突然的改变，并且计划的改变通常以为着要付出代价，别人不一定能够接受这样的代价。</li><li><strong>如果事关自己</strong>，可以争取改变，毕竟自己能够承担自己做的事情带来的代价。</li></ol><p>这次就算了，好好享受这一场演唱会，想太多也没有用，期待演出捏</p><p><img src="image-20231101210351116.png" alt="image-20231101210351116"></p><p>最后附上新裤子的一首歌，歌名与今日感受十分贴切，🎧   ----&gt;  <a href="https://music.163.com/#/song?id=2033879001">荒废的一天</a></p><p>END/</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 本人的碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux设备驱动开发</title>
      <link href="/2023/11/01/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/11/01/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1>概述</h1><p><img src="image-20231117114308618.png" alt="image-20231117114308618"></p><p><strong>用户空间与内核空间的交互</strong></p><ul><li>应用程序可以直接使用Linux 的系统调用，也可使用C 库函数。一般都是用后者。</li></ul><p><strong>C标准库与POSIX库</strong></p><ul><li>C标准库和POSIX库都是在不同层次上提供了对操作系统功能的封装，但它们的目标和功能有所不同。</li><li>在层次结构上，可以说POSIX库在某种程度上是C标准库的扩展，增加了对系统级别的支持。因此，可以认为POSIX库更高级，因为它提供了更多的功能，但也更加特定于操作系统。</li></ul><h1>Linux 设备驱动的重点、难点</h1><ul><li>编写 Linux 设备驱动要求工程师有非常好的硬件基础，**懂得 SRAM、Flash、SDRAM、<br>磁盘的读写方式，UART、I2C、USB 等设备的接口以及轮询、中断、DMA 的原理，<br>PCI 总线的工作方式以及CPU 的内存管理单元（MMU）**等。</li><li>编写 Linux 设备驱动要求工程师有非常好的 C 语言基础，能灵活地运用 C 语言的结<br>构体、指针、函数指针及<strong>内存动态申请和释放</strong>等。</li><li>编写 Linux 设备驱动要求工程师有一定的 Linux 内核基础，虽然并不要求工程师对<br>内核各个部分有深入的研究，但**至少要明白驱动与内核的接口。尤其是对于块设<br>备、网络设备、Flash 设备、串口设备等复杂设备，**内核定义的驱动体系结构本身就<br>非常复杂。</li><li>编写 Linux 设备驱动要求工程师<strong>有非常好的多任务并发控制和同步的基础，因为在驱<br>动中会大量使用自旋锁、互斥、信号量、等待队列等并发与同步机制。</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>按键驱动</title>
      <link href="/2023/10/27/%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/10/27/%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>前言</h1><p>实现按键驱动有四种：<br>①、查询方式、————非常耗CPU<br>②、休眠-唤醒、 ———— 如果条件不满足，应用程序则一直睡眠下去<br>③、poll机制、————如果条件不满足，休眠指定的时间，休眠时间内条件满足唤醒，条件一直不满足时间到达自动唤醒<br>④、异步通知————应用程序注册信号处理函数，驱动程序发信号（signal io）</p><p><strong>驱动程序框架</strong>：</p><blockquote><p>APP: ---------------------open-------------read--------------write</p><p>————————————————————————————</p><p>驱动：--------------<strong>drv_open</strong>-------<strong>drv_read</strong>--------<strong>drv_write</strong></p><p>1️⃣     <strong>file_operation</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_openation</span> <span class="title">my_device</span> =</span> &#123;</span><br><span class="line">    .open  = drv_open,</span><br><span class="line">    .read  = drv_read,</span><br><span class="line">    .write = drv_wirte,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2️⃣<strong>register_chrdev</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">register_chrdev(major, <span class="string">&quot;name&quot;</span>, file_operation &amp;my_device); <span class="comment">//  /dev/name </span></span><br></pre></td></tr></table></figure><p>3️⃣ <strong>入口函数</strong> ——装载驱动程序时，入口函数就会自动被系统调用</p><p>4️⃣ <strong>出口函数</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驱动开发框架</title>
      <link href="/2023/10/26/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/10/26/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="目录">目录</h4><ul><li>通用驱动框架</li><li>简单的hello驱动</li><li>GPIO</li></ul><h4 id="通用驱动框架">通用驱动框架</h4><ol><li>确定主设备号</li><li>定义自己的<code>file_operator</code>结构体</li><li>实现对应的<code>open\read\write</code>等函数，填入<code>file_operator</code>结构体</li><li>把<code>file_operator</code>结构体告诉内核：注册驱动程序</li><li>入口函数：安装驱动程序时就会调用该入口函数</li><li>出口函数：卸载驱动程序时，就会调用该出口函数</li><li>其他完善：提供设备信息，自动创建设备节点</li></ol><h4 id="简单的hello驱动（不涉及硬件）">简单的hello驱动（不涉及硬件）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 确定主设备号 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kernel_buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b)   (a&lt;b?a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 实现对应的open、read、write函数，填入file_operation结构体 */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    copy_to_user(buf, kernel_buf, MIN(<span class="number">1024</span>, size));</span><br><span class="line">    <span class="keyword">return</span> MIN(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    copy_from_user(kernel_buf, buf, MIN(<span class="number">1024</span>, size));</span><br><span class="line">    <span class="keyword">return</span> MIN(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 定义自己的file_operation结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operation</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">    .owner  = THIS_MODULW,</span><br><span class="line">    .open   = hello_drv_open,</span><br><span class="line">    .read   = hello_drv_read,</span><br><span class="line">    .write  = hello_drv_write,</span><br><span class="line">    .release = hello_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4. 注册驱动程序，把file_operation结构体告诉内核 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5. 入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, &amp;hello_drv); </span><br><span class="line"></span><br><span class="line">    hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>); <span class="comment">/* /dev/hello */</span></span><br><span class="line">err = PTR_ERR(hello_class);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(hello_class))</span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6. 出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    device_destory(hello_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destory(hello_class);</span><br><span class="line"></span><br><span class="line">    unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. 其他完善：提供设备信息，自动创建节点 */</span></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>__FILE__</code> 是预处理器宏，用于表示当前源文件名。</li><li><code>__FUNCTION__</code> 是编译器宏，用于表示当前函数名。</li><li><code>__LINE__</code> 是预处理器宏，用于表示当前行号。</li></ul><p>这些宏常用于调试，以了解代码的执行位置。</p><ul><li><code>printk</code> 是Linux内核中用于打印调试信息的函数，类似于C标准库中的 <code>printf</code>。</li></ul><h4 id="GPIO">GPIO</h4><ol><li>使能 power/clock</li><li>选择pin’mode (pin’mode可以是uart或gpio等等)</li><li>方向：读 or 写</li><li>数据：高电平 or 低电平</li></ol><p><img src="image-20231027163401069.png" alt="GPIO"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
