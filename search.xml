<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>同步与异步</title>
      <link href="/2023/12/12/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
      <url>/2023/12/12/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="同步与异步">同步与异步</h3><p><strong>同步</strong>（即阻塞模式）：<strong>同步通信的双方需要频率一致的时钟。</strong>（如IIC，SPI）</p><p><strong>异步</strong>（即非阻塞模式）：<strong>异步通信的双方使用各自的时钟</strong>（如UART），接收方是通过识别数据包中的起始位和结束位来实现信息同步的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UART深入剖析</title>
      <link href="/2023/12/07/UART%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/"/>
      <url>/2023/12/07/UART%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="UART深入剖析">UART深入剖析</h3><p><strong>UART</strong>是一种串行、异步、全双工的通信协议。</p><p>UART由三根数据线构成：TXRXGND</p><ul><li><p>**空闲位：**空闲状态时信号线为高电平</p></li><li><p>**起始位：**发送方先发出低电平，表示传输字符的开始。</p></li><li><p><strong>数据位：<strong>起始位之后就是我们所要传输的数据，数据位可以是5、6、7、8，9位等，构成一个字符（一般都是8位）。先发送</strong>最低位</strong>，最后发送<strong>最高位</strong>。</p></li><li><p>**奇偶校验位：**数据位加上这一位，可以校验数据传送的正确性。</p></li><li><p>**停止位：**它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。</p></li></ul><p><img src="image-20231212102929836.png" alt="image-20231212102929836"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPI深入剖析</title>
      <link href="/2023/12/06/SPI/"/>
      <url>/2023/12/06/SPI/</url>
      
        <content type="html"><![CDATA[<h4 id=""></h4><h3 id="SPI深入剖析">SPI深入剖析</h3><ul><li><p>SPI是同步通信协议</p></li><li><p>SPI接口有4条数据线：SCKSSMOSI　MISO</p></li></ul><h4 id="SPI-通信流程"><strong>SPI 通信流程</strong></h4><p>主设备选通一个或多个从设备，将 SS 线拉低，以确定通信目标。</p><p>主设备通过 SCLK 线产生时钟信号，驱动数据在 MOSI 上发送给从设备。</p><p>从设备根据时钟信号，在 MISO 上将响应数据返回给主设备。</p><p>通信完成后，主设备将 SS 线拉高，释放从设备。</p><h4 id="时钟极性（CPOL）与时钟相位（CPHA）">时钟极性（CPOL）与时钟相位（CPHA）</h4><p>SPI通信可以配置为不同的时钟极性和相位。</p><p>时钟极性定义时钟在空闲状态时的电平</p><ul><li>如果CPOL= 0，串行同步时钟的空闲状态为低电平；</li><li>如果CPOL= 1，串行同步时钟的空闲状态为高电平。</li></ul><p>时钟相位定义数据采样的时机</p><ul><li><p>如果CPHA= 0，在串行同步时钟的第一个跳变沿（上升或下降）数据被采样；</p></li><li><p>如果CPHA = 1，在串行同步时钟的第二个跳变沿（上升或下降）数据被采样。</p></li></ul><p><img src="image-20231211102038775.png" alt="image-20231211102038775"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIC深入剖析</title>
      <link href="/2023/12/06/IIC/"/>
      <url>/2023/12/06/IIC/</url>
      
        <content type="html"><![CDATA[<h3 id="I2C总线与I2C通信协议的区别">I2C总线与I2C通信协议的区别</h3><ul><li><p><strong>I2C总线是硬件概念：</strong> I2C总线是<strong>物理连接设备的电缆和线路</strong>。它提供了设备之间进行串行通信的基础结构。</p></li><li><p><strong>I2C协议是通信规则：</strong> I2C协议定义了在I2C总线上设备之间如何进行<strong>通信的规则</strong>。它规定了数据的传输格式、起始和停止条件、时钟频率等。</p></li></ul><h3 id="IIC详解">IIC详解</h3><p>IIC是多主机的半双工同步通信协议，<strong>数据线SDA</strong>和<strong>时钟线SCL</strong>构成。</p><blockquote><ol><li>各设备连接到总线的输出端必须是<strong>开漏输出</strong>或集电极开路输出的结构</li><li>在任意时刻只能有一个主控</li></ol></blockquote><p>空闲状态，上拉电阻使SDA和SCL信号线同时处于高电平；</p><p>由于**”线与“**逻辑，I2C总线上任意器件输出低电平都会使相应总线上的信号线变低；</p><h4 id="开始位和停止位">开始位和停止位</h4><p>当SCL 稳定在高电平时，SDA 由高到低的变化将产生一个开始位，而由低到高的变化，则产生一个停止位。</p><p><img src="image-20231211210806975.png" alt="image-20231211210806975"></p><ul><li>开始位和停止位都由I2C 主设备产生。</li></ul><p>在选择从设备时，如果从设备采用7 位地址，则主设备在发起传输过程前，需先发送1 字节的地址信息，前7 位为设备地址，最后1 位为读写标志。之后，每次传输的数据也是1字节，从MSB 开始传输。</p><p>每个字节传完后，在SCL的第9个上升沿到来之前，接收方应该发出1个ACK 位。</p><blockquote><ol><li><p>SCL 上的时钟脉冲由I2C主控方发出</p></li><li><p>在第8个时钟周期之后，主控方应该释放<strong>SDA</strong>。(因为要让给从机响应ACK)</p></li></ol></blockquote><p><img src="image-20231211211114744.png" alt="image-20231211211114744"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Windows使用VSCode搭建嵌入式Linux开发环境</title>
      <link href="/2023/12/05/%E5%9C%A8Windows%E4%BD%BF%E7%94%A8VSCode%E6%90%AD%E5%BB%BA%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/12/05/%E5%9C%A8Windows%E4%BD%BF%E7%94%A8VSCode%E6%90%AD%E5%BB%BA%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/在Windows使用VSCode搭建嵌入式Linux开发环境.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实战1：led驱动</title>
      <link href="/2023/11/06/%E5%AE%9E%E6%88%981%EF%BC%9Aled%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/11/06/%E5%AE%9E%E6%88%981%EF%BC%9Aled%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="实战1：led驱动">实战1：led驱动</h3><blockquote><p>环境：</p><p>首先配置好bear make、clangd、compile_command.json等等插件和环境，在windows下用vscode来ssh链接到虚拟机；</p><p>在vscode创建workspace；</p><p>串口工具使用MobaXterm；</p></blockquote><h4 id="驱动程序"><strong>驱动程序</strong></h4><ol><li><h5 id="不知道加什么头文件？✅-复制内核代码其他设备驱动的头文件！">不知道加什么头文件？✅ <strong>复制内核代码其他设备驱动的头文件！</strong></h5></li></ol><ul><li>cd 至内核的设备驱动目录</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/.../Linux-4.9.88/drivers/char</span><br></pre></td></tr></table></figure><ul><li>用grep查找”register_chrdev“</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;register_chrdev&quot;</span> * -nwr// 星号表示所有目录</span><br></pre></td></tr></table></figure><p>找到如下文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ds1302.c:349:   if (register_chrdev(RTC_MAJOR_NR, ds1302_name, &amp;rtc_fops)) &#123;</span><br><span class="line">dsp56k.c:503:   if(register_chrdev(DSP56K_MAJOR, &quot;dsp56k&quot;, &amp;dsp56k_fops)) &#123;</span><br><span class="line">dtlk.c:338:     dtlk_major = register_chrdev(0, &quot;dtlk&quot;, &amp;dtlk_fops);</span><br><span class="line">ipmi/ipmi_devintf.c:950:        rv = register_chrdev(ipmi_major, DEVICE_NAME, &amp;ipmi_fops);</span><br><span class="line">lp.c:980:       if (register_chrdev (LP_MAJOR, &quot;lp&quot;, &amp;lp_fops)) &#123;</span><br><span class="line">mbcs.c:815:     rv = register_chrdev(mbcs_major, DEVICE_NAME, &amp;mbcs_ops);</span><br><span class="line">mem.c:898:      if (register_chrdev(MEM_MAJOR, &quot;mem&quot;, &amp;memory_fops))</span><br><span class="line">misc.c:290:     if (register_chrdev(MISC_MAJOR,&quot;misc&quot;,&amp;misc_fops))</span><br><span class="line">pcmcia/cm4040_cs.c:659: major = register_chrdev(0, DEVICE_NAME, &amp;reader_fops);</span><br><span class="line">pcmcia/cm4000_cs.c:1897:        major = register_chrdev(0, DEVICE_NAME, &amp;cm4000_fops);</span><br><span class="line">ppdev.c:851:    if (register_chrdev(PP_MAJOR, CHRDEV, &amp;pp_fops)) &#123;</span><br><span class="line">tb0219.c:301:   retval = register_chrdev(major, &quot;TB0219&quot;, &amp;tb0219_fops);</span><br><span class="line">tlclk.c:780:    ret = register_chrdev(tlclk_major, &quot;telco_clock&quot;, &amp;tlclk_fops);</span><br><span class="line">virtio_console.c:2047:  portdev-&gt;chr_major = register_chrdev(0, &quot;virtio-portsdev&quot;,</span><br></pre></td></tr></table></figure><p>找到一个合适的，进去复制头文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm-generic/errno-base.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm-generic/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm/uaccess.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li><h5 id="定义gpio引脚">定义gpio引脚</h5></li></ol><ul><li>注意：gpio引脚需要查imx6ull底板图来确认，根据查询找到<code>led</code>在<code>gpio5_3</code></li></ul><p>串口连接到单片机，查看gpio</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/kernel/debug/gpio</span><br></pre></td></tr></table></figure><p>得到如下输出：</p><p><img src="image-20231205173431102.png" alt="image-20231205173431102"></p><p>因此确认<code>gpio5_3</code>在 <code>131</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>&#123;</span></span><br><span class="line"><span class="type">int</span> gpio;</span><br><span class="line"><span class="type">int</span> irq;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> <span class="title">gpios</span>[2] =</span> &#123;</span><br><span class="line">    &#123;<span class="number">131</span>, <span class="number">0</span>, <span class="string">&quot;led0&quot;</span>&#125;,</span><br><span class="line"><span class="comment">//&#123;132, 0, &quot;led1&quot;&#125;,</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li><h5 id="完成入口函数等等，在此不赘述">完成入口函数等等，在此不赘述</h5></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 主设备号                                                                 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_class</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现对应的open/read/write等函数，填入file_operations结构体                   */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">gpio_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> tmp_buf[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="type">int</span> count = <span class="keyword">sizeof</span>(gpios)/<span class="keyword">sizeof</span>(gpios[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = copy_from_user(tmp_buf, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp_buf[<span class="number">0</span>] &gt;= count)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">tmp_buf[<span class="number">1</span>] = gpio_get_value(gpios[tmp_buf[<span class="number">0</span>]].gpio);</span><br><span class="line"></span><br><span class="line">err = copy_to_user(buf, tmp_buf, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">gpio_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ker_buf[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">err = copy_from_user(ker_buf, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ker_buf[<span class="number">0</span>] &gt;= <span class="keyword">sizeof</span>(gpios)/<span class="keyword">sizeof</span>(gpios[<span class="number">0</span>]))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">gpio_set_value(gpios[ker_buf[<span class="number">0</span>]].gpio, ker_buf[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义自己的file_operations结构体                                              */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.read    = gpio_drv_read,</span><br><span class="line">.write   = gpio_drv_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_drv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> count = <span class="keyword">sizeof</span>(gpios)/<span class="keyword">sizeof</span>(gpios[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">&#123;</span><br><span class="line">err = gpio_request(gpios[i].gpio, gpios[i].name);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;can&#x27;t not require gpio %s\n&quot;</span>, gpios[i].name);</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gpio_direction_output(gpios[i].gpio, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册file_operations */</span></span><br><span class="line">major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_led&quot;</span>, &amp;gpio_key_drv);  <span class="comment">/* /dev/gpio_desc */</span></span><br><span class="line"></span><br><span class="line">gpio_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_led_class&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(gpio_class)) &#123;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">unregister_chrdev(major, <span class="string">&quot;100ask_led_class&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(gpio_class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">device_create(gpio_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_led&quot;</span>); <span class="comment">/* /dev/100ask_gpio */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_drv_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> count = <span class="keyword">sizeof</span>(gpios)/<span class="keyword">sizeof</span>(gpios[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">device_destroy(gpio_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">class_destroy(gpio_class);</span><br><span class="line">unregister_chrdev(major, <span class="string">&quot;100ask_led&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">&#123;</span><br><span class="line">gpio_free(gpios[i].gpio);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */</span></span><br><span class="line"></span><br><span class="line">module_init(gpio_drv_init);</span><br><span class="line">module_exit(gpio_drv_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试程序"><strong>测试程序</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//int led_on(int which);</span></span><br><span class="line"><span class="comment">//int led_off(int which);</span></span><br><span class="line"><span class="comment">//int led_status(int which);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./led_test &lt;0|1|2|..&gt;  on </span></span><br><span class="line"><span class="comment"> * ./led_test &lt;0|1|2|..&gt;  off</span></span><br><span class="line"><span class="comment"> * ./led_test &lt;0|1|2|..&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 判断参数 */</span></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;0|1|2|...&gt; [on | off]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 打开文件 */</span></span><br><span class="line">fd = open(<span class="string">&quot;/dev/100ask_led&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;can not open file /dev/100ask_led\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* write */</span></span><br><span class="line">buf[<span class="number">0</span>] = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;on&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buf[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ret = write(fd, buf, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">buf[<span class="number">0</span>] = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">ret = read(fd, buf, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;led %d status is %s\n&quot;</span>, buf[<span class="number">0</span>], buf[<span class="number">1</span>] == <span class="number">0</span> ? <span class="string">&quot;on&quot;</span> : <span class="string">&quot;off&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><h5 id="写完后，更改Makefile，把led-dev-ko-和-test-drv复制到挂载目录下，在板子上插入模块。">写完后，更改Makefile，把led_dev.ko 和 test_drv复制到挂载目录下，在板子上插入模块。</h5></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod led_drv.ko</span><br></pre></td></tr></table></figure><p>–END；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户线程和内核线程区别</title>
      <link href="/2023/11/05/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/11/05/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="用户线程：">用户线程：</h3><ol><li><strong>创建和管理：</strong> 用户线程是由用户空间的应用程序创建和管理的。用户线程的创建、调度和销毁完全由用户程序的线程库（用户级线程库）负责，而不需要内核的干预。</li><li><strong>轻量级：</strong> 用户线程是轻量级的，它们的创建和上下文切换开销相对较小。因为这些线程的管理是在用户空间进行的，不需要内核介入。</li><li><strong>阻塞：</strong> 当用户线程中的一个线程被阻塞时，整个进程可能被阻塞，因为内核不了解和不管理用户线程的阻塞状态。</li><li><strong>调度：</strong> 用户线程的调度是由用户级线程库实现的，通常是基于协作式调度（cooperative scheduling）。这意味着一个用户线程在执行期间可以主动让出 CPU 控制权。</li><li><strong>无法利用多核：</strong> 由于用户线程的调度是在用户空间完成的，内核无法将不同的用户线程分配到不同的核上运行，因此用户线程不能充分利用多核处理器的优势。</li></ol><h3 id="内核线程：">内核线程：</h3><ol><li><strong>创建和管理：</strong> 内核线程是由操作系统内核创建和管理的。内核线程的创建和销毁由内核负责，而不需要用户空间的干预。</li><li><strong>重量级：</strong> 内核线程是相对重量级的，因为它们的创建和上下文切换涉及到内核的介入。这导致了相对较高的开销。</li><li><strong>阻塞：</strong> 当一个内核线程被阻塞时，通常只影响到该线程，而不会影响整个进程。其他内核线程仍然可以在系统中执行。</li><li><strong>调度：</strong> 内核线程的调度是由操作系统内核的调度器实现的，通常是基于抢占式调度（preemptive scheduling）。这意味着内核线程可以被强制剥夺 CPU 控制权。</li><li><strong>多核利用：</strong> 内核线程可以更好地利用多核处理器，因为内核可以将不同的内核线程分配给不同的核。</li></ol><h3 id="总结：">总结：</h3><ul><li>用户线程更轻量级，由用户程序自己的线程库管理，但在阻塞和调度方面有一些限制。</li><li>内核线程更重量级，由操作系统内核管理，提供更好的阻塞和调度支持，并且能够更好地利用多核处理器。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程上下文与中断上下文区别</title>
      <link href="/2023/11/05/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/11/05/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="1-上下文切换触发时机：">1. 上下文切换触发时机：</h4><ul><li><strong>进程上下文：</strong> 进程上下文是在内核中执行进程代码时的执行环境。它通常由系统调用、中断、异常或调度程序引起。在进程上下文中，内核代码运行在进程的地址空间中。</li><li><strong>中断上下文：</strong> 中断上下文是在响应硬件中断时执行的上下文。硬件中断可以来自外部设备或是软中断触发的。中断上下文执行的代码是内核中的中断服务程序。</li></ul><h4 id="2-实时性要求：">2. 实时性要求：</h4><ul><li><strong>进程上下文：</strong> 进程上下文不要求实时性，允许较长时间的执行。因为进程上下文的切换是由操作系统的调度器控制的，可以在较长的时间间隔内完成。</li><li><strong>中断上下文：</strong> 中断上下文通常需要满足实时性的要求，因为中断服务程序必须迅速响应硬件中断。中断上下文中执行的代码应该尽量保持简短和快速。</li></ul><h4 id="3-中断屏蔽：">3. 中断屏蔽：</h4><ul><li><strong>进程上下文：</strong> 进程上下文中，中断是可以被屏蔽的。这意味着在进程上下文中执行的代码可以选择屏蔽中断，以防止中断干扰。</li><li><strong>中断上下文：</strong> 中断上下文是在中断时执行的，中断是不能被屏蔽的。中断服务程序必须响应中断，并且中断服务程序执行期间其他中断是被屏蔽的，以防止嵌套中断。</li></ul><h4 id="4-执行环境：">4. 执行环境：</h4><ul><li><strong>进程上下文：</strong> 进程上下文中，内核代码可以访问用户空间的地址空间，执行用户空间和内核空间的代码。</li><li><strong>中断上下文：</strong> 中断上下文中，内核代码只能访问内核空间，不能执行用户空间的代码。</li></ul><h4 id="5-响应性：">5. 响应性：</h4><ul><li><strong>进程上下文：</strong> 进程上下文的切换可以由操作系统的调度器控制，因此响应性较低。进程上下文切换可能需要等待调度器的调度决策。</li><li><strong>中断上下文：</strong> 中断上下文是由硬件中断引起的，响应性较高。中断服务程序迅速响应中断，不需要等待调度器。</li></ul><h4 id="总结：">总结：</h4><ul><li>进程上下文用于执行较长时间的内核代码，对实时性要求较低。</li><li>中断上下文用于迅速响应硬件中断，对实时性有较高的要求。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中断编程</title>
      <link href="/2023/11/04/Linux%E4%B8%AD%E6%96%AD%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/11/04/Linux%E4%B8%AD%E6%96%AD%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="申请和释放中断">申请和释放中断</h4><p>在Linux设备驱动中，使用中断的设备需要<strong>申请</strong>和<strong>释放</strong>对应的中断。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请中断</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放irq</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure><h4 id="底半部机制">底半部机制</h4><p>Linux实现底半部的机制主要有tasklet、工作队列、软中断、线程化irq；</p><h5 id="tasklet">tasklet</h5><p>tasklet的执行上下文是软中断，执行时机通常是顶半部返回的时候。</p><blockquote><p>软中断的执行相对于硬中断而言，更加灵活、不需要严格的实时性，并且能够在内核中执行较长时间的任务。</p></blockquote><p>使用 <code>tasklet</code> 时，一般的流程是：</p><ol><li><p><strong>注册 <code>tasklet</code>：</strong> 在驱动程序初始化阶段，通过 <code>tasklet_init()</code> 函数初始化一个 <code>tasklet</code> 结构，并通过 <code>tasklet_init()</code> 函数将其注册到内核中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_tasklet_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行 tasklet 相关的处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在初始化阶段注册 tasklet</span></span><br><span class="line">tasklet_init(&amp;my_tasklet, my_tasklet_function, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>触发 <code>tasklet</code>：</strong> 当驱动程序需要执行与 <code>tasklet</code> 相关的工作时，调用 <code>tasklet_schedule()</code> 函数触发 <code>tasklet</code> 的执行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在需要的时候触发 tasklet 执行</span></span><br><span class="line">tasklet_schedule(&amp;my_tasklet);</span><br></pre></td></tr></table></figure></li><li><p><strong>处理函数执行：</strong> 当内核下一次进入软中断上下文时，内核会检查 <code>tasklet</code> 的状态，如果处于待运行状态，就执行与之关联的处理函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_interrupt_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理中断的逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发 tasklet 执行</span></span><br><span class="line">    tasklet_schedule(&amp;my_tasklet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>总体来说，<code>tasklet_schedule()</code> 的作用是标记一个 <code>tasklet</code> 为待运行状态，以便在适当的上下文中执行与之相关的处理函数。这有助于避免在中断上下文中执行耗时的操作，从而提高系统的响应性。</p><h5 id="工作队列">工作队列</h5><p>工作队列的使用方法和<code>tasklet</code>非常相似，但是工作队列的执行上下文是内核线程，因此可以调度和睡眠。</p><p>使用 <code>工作队列</code> 时，一般的流程是：</p><ol><li><p><strong>注册工作队列：</strong> 定义一个工作队列和底半部执行函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">my_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_work_function</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行工作队列中的任务</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化和调度：</strong> 通过调用 <code>INIT_WORK</code> 宏将工作结构和处理函数关联，并通过 <code>schedule_work</code> 或 <code>queue_work</code> 函数将工作结构插入工作队列，以便在后台执行相关处理函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INIT_WORK(&amp;my_work, my_work_function);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度工作队列执行</span></span><br><span class="line">schedule_work(&amp;my_work);</span><br></pre></td></tr></table></figure></li></ol><h5 id="软中断">软中断</h5><p>软中断(Softirq)也是一种传统的底半部处理机制，它的执行时机通常是顶半部返回的时候，tasklet是基于软中断实现的，因此也运行于软中断上下文。</p><h5 id="threaded-irq">threaded_irq</h5><p><code>threaded_irq</code> 函数是 Linux 内核中用于注册<strong>线程化中断处理程序（threaded interrupt handler）的函数。</strong></p><ol><li><strong>上下文执行环境：</strong> <code>threaded_irq</code> 注册的中断处理程序在线程上下文中执行。线程上下文是在进程上下文中执行的，不要求严格的实时性，因此可以执行较长时间的任务。</li><li><strong>处理程序类型：</strong> <code>threaded_irq</code> 注册的中断处理程序是一个线程化中断处理程序。这意味着它可以执行较长时间的任务，而不会阻塞中断线。</li><li><strong>不阻塞中断线：</strong> 当 <code>threaded_irq</code> 注册的中断处理程序正在执行时，不会阻塞同一中断线上的其他中断处理程序。这允许多个中断处理程序并发执行。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常与中断</title>
      <link href="/2023/11/03/%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD/"/>
      <url>/2023/11/03/%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h4 id="异常与中断的概念与处理流程">异常与中断的概念与处理流程</h4><p><img src="image-20231129164249697.png" alt="image-20231129164249697"></p><ol><li>中断源</li><li>中断控制器</li><li>CPU</li></ol><h4 id="异常与中断有何区别">异常与中断有何区别</h4><p><strong>异常</strong>：主要用于处理程序执行期间的错误</p><p><strong>中断</strong>：主要用于处理外部设备或其他处理器的事件通知（e.g. 硬件中断，定时器中断）</p><h4 id="arm对异常-中断-处理过程：">arm对异常(中断)处理过程：</h4><ol><li><p>初始化：</p><blockquote><ol><li>设置中断源</li><li>设置中断控制器</li><li>设置CPU总开关（使能中断）</li></ol></blockquote></li><li><p>执行其他程序</p></li><li><p>产生中断：比如按下按键 --&gt; 中断控制器 --&gt; CPU</p></li><li><p>CPU每执行完一条指令都会检查有无中断/异常产生</p></li><li><p>CPU发现由中断/异常产生，开始处理。</p><blockquote><p>对于不同的异常，跳去不同的地址执行程序。该地址只有一条跳转指令，跳去执行某个函数（地址），这个就是<strong>异常向量</strong>。</p><p>异常向量表包含了一组异常处理程序的入口地址，每个异常/中断对应一个地址。当中断发生时，处理器会从异常向量表中找到相应的地址并跳转到那里执行。</p></blockquote></li><li><p>跳转的函数执行：</p><blockquote><ol><li>保存现场：各种寄存器</li><li>处理异常/中断：分辨中断源，再调用不同的处理函数。</li><li>恢复现场</li></ol></blockquote></li></ol><blockquote><p><strong>注意：上面的3，4，5都是硬件做的。</strong></p></blockquote><h4 id="Linux中断程序架构">Linux中断程序架构</h4><p><strong>中断处理原则</strong></p><ol><li>中断不能嵌套</li><li>中断处理时间越快越好</li></ol><p>但是由于中断处理程序通常比较耗时，Linux将中断处理程序分别两个半部：<strong>上半部</strong>和<strong>下半部</strong></p><p><img src="image-20231130154431818.png" alt="image-20231130154431818"></p><ul><li><p>上半部用于完成尽量少的比较紧急的任务。<strong>（通常被设计为不可被新的中断打断）</strong></p><blockquote><p>通常只是简单读取寄存器的中断状态，并在清除中断标志位后进行“登记中断“的工作，”登记中断“意味着将底半部处理程序挂到该设备的底半部执行队列中去。</p></blockquote></li><li><p>底半部几乎做了中断处理程序的所有事情。<strong>（通常被设计为可以被新的中断打断）</strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奇奇怪怪的碎碎念</title>
      <link href="/2023/11/01/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2023/11/01/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1>2023年11月份的碎碎念</h1><h2 id="11月的第一个星期">11月的第一个星期</h2><p>emotion：😭😭😭😭😭</p><p>🎸起因：新裤子北海怪兽演唱，本来没打算抢票的我，总觉得都开到家门口了，不抢怪可惜的。</p><blockquote><p>起初不打算抢票的原因：</p><ol><li>感觉新裤子越来越流行化了，觉得朋克太土了。</li><li>总觉得开演唱会太不像摇滚乐做的事儿了，摇滚乐就应该好好呆在livehouse，</li></ol><p>改变心意的原因：</p><ol><li>前一天晚上看了月夏最后一集的演唱会，朋克虽然土，但真的好容易让人回荡起被琐碎日子磨平的情绪，不用思考，没有晦涩的歌词，没有刻意制造的深刻，没有对社会的苦大仇深与抨击。我在这总是能感到裸露的情绪，为自己还能感受世界而庆幸。</li><li>第二个原因就是距离真的太近了，离学校只有不到2km的距离。</li></ol></blockquote><p>🌸经过：下午四点突然收到新裤子演唱会放票的信息，点进去一看发现280、580、780、980的票都有，我当机立断就想起前一天晚上想到如果有票的话叫上FL哥，但是之前根本没录入他们的个人身份信息，买票的时候就需要重新录入，一通下来本来可以抢到280票的我，硬生生因为录入他们的信息花了太多时间，错过280的票。此时已经很冲动了，想要去看演唱会的心情达到峰值，简单询问了一下就买了580的票乘4！！！！</p><p>🌰结果：太贵了！！太亏了！！还不能退票！！退票要收20%的手续费！！搞的FL哥和章鱼哥莫名支出了一大笔钱，关键是原本是不想看的，就算想看也是最便宜的票，一下子就比原计划多花了三百块！！！而且其实大家都互相不认识，感觉会尴尬。</p><p>而且FL哥感觉没有很想去，这波是擅自给别人做决定了，本来是打算买280的票然后就请他看的，因为冲动买票的行为导致也请不起了。</p><p>😭 导致：emo了一下午，觉得自己做事情太冲动太冲动，太不成熟，以此为鉴，得出一些结论，希望以后能减少此类事情的发生：</p><p>🌏心得：</p><ol><li><strong>提前确定好买票人，不要临时更改</strong>。如果有临时想叫的人，先管好已经定下来的，再去问别人。</li><li>提前录入买票人信息和取票地址。</li><li>不一定要一起买，不用为了连座特地一起买票，<strong>没有抢到票一切都是徒劳的</strong>。</li><li>只买最便宜一档的票！没有了就不买！因为总会等到有人出的！！</li><li>面对突如其来的票，先管自己的，再去管别人的，不带来不必要的麻烦。</li></ol><p>将该抢票心得映射到其他的事情上：</p><ol><li>不要在心急的时候做决定！不要被突如其来的计划改变乱了阵脚！如果实在计划有变，考虑此事事关自己还是事关他人，</li><li><strong>如若事关他人</strong>，则不要轻易改变计划，别人不一定能接受突然的改变，并且计划的改变通常以为着要付出代价，别人不一定能够接受这样的代价。</li><li><strong>如果事关自己</strong>，可以争取改变，毕竟自己能够承担自己做的事情带来的代价。</li></ol><p>这次就算了，好好享受这一场演唱会，想太多也没有用，期待演出捏</p><p><img src="image-20231101210351116.png" alt="image-20231101210351116"></p><p>最后附上新裤子的一首歌，歌名与今日感受十分贴切，🎧   ----&gt;  <a href="https://music.163.com/#/song?id=2033879001">荒废的一天</a></p><p>END/</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 本人的碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux设备驱动开发</title>
      <link href="/2023/11/01/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/11/01/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1>概述</h1><p><img src="image-20231117114308618.png" alt="image-20231117114308618"></p><p><strong>用户空间与内核空间的交互</strong></p><ul><li>应用程序可以直接使用Linux 的系统调用，也可使用C 库函数。一般都是用后者。</li></ul><p><strong>C标准库与POSIX库</strong></p><ul><li>C标准库和POSIX库都是在不同层次上提供了对操作系统功能的封装，但它们的目标和功能有所不同。</li><li>在层次结构上，可以说POSIX库在某种程度上是C标准库的扩展，增加了对系统级别的支持。因此，可以认为POSIX库更高级，因为它提供了更多的功能，但也更加特定于操作系统。</li></ul><h1>Linux 设备驱动的重点、难点</h1><ul><li>编写 Linux 设备驱动要求工程师有非常好的硬件基础，**懂得 SRAM、Flash、SDRAM、<br>磁盘的读写方式，UART、I2C、USB 等设备的接口以及轮询、中断、DMA 的原理，<br>PCI 总线的工作方式以及CPU 的内存管理单元（MMU）**等。</li><li>编写 Linux 设备驱动要求工程师有非常好的 C 语言基础，能灵活地运用 C 语言的结<br>构体、指针、函数指针及<strong>内存动态申请和释放</strong>等。</li><li>编写 Linux 设备驱动要求工程师有一定的 Linux 内核基础，虽然并不要求工程师对<br>内核各个部分有深入的研究，但**至少要明白驱动与内核的接口。尤其是对于块设<br>备、网络设备、Flash 设备、串口设备等复杂设备，**内核定义的驱动体系结构本身就<br>非常复杂。</li><li>编写 Linux 设备驱动要求工程师<strong>有非常好的多任务并发控制和同步的基础，因为在驱<br>动中会大量使用自旋锁、互斥、信号量、等待队列等并发与同步机制。</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>按键驱动</title>
      <link href="/2023/10/27/%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/10/27/%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>前言</h1><p>实现按键驱动有四种：<br>①、查询方式、————非常耗CPU<br>②、休眠-唤醒、 ———— 如果条件不满足，应用程序则一直睡眠下去<br>③、poll机制、————如果条件不满足，休眠指定的时间，休眠时间内条件满足唤醒，条件一直不满足时间到达自动唤醒<br>④、异步通知————应用程序注册信号处理函数，驱动程序发信号（signal io）</p><p><strong>驱动程序框架</strong>：</p><blockquote><p>APP: ---------------------open-------------read--------------write</p><p>————————————————————————————</p><p>驱动：--------------<strong>drv_open</strong>-------<strong>drv_read</strong>--------<strong>drv_write</strong></p><p>1️⃣     <strong>file_operation</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_openation</span> <span class="title">my_device</span> =</span> &#123;</span><br><span class="line">    .open  = drv_open,</span><br><span class="line">    .read  = drv_read,</span><br><span class="line">    .write = drv_wirte,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2️⃣<strong>register_chrdev</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">register_chrdev(major, <span class="string">&quot;name&quot;</span>, file_operation &amp;my_device); <span class="comment">//  /dev/name </span></span><br></pre></td></tr></table></figure><p>3️⃣ <strong>入口函数</strong> ——装载驱动程序时，入口函数就会自动被系统调用</p><p>4️⃣ <strong>出口函数</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驱动开发框架</title>
      <link href="/2023/10/26/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/10/26/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="目录">目录</h4><ul><li>通用驱动框架</li><li>简单的hello驱动</li><li>GPIO</li></ul><h4 id="通用驱动框架">通用驱动框架</h4><ol><li>确定主设备号</li><li>定义自己的<code>file_operator</code>结构体</li><li>实现对应的<code>open\read\write</code>等函数，填入<code>file_operator</code>结构体</li><li>把<code>file_operator</code>结构体告诉内核：注册驱动程序</li><li>入口函数：安装驱动程序时就会调用该入口函数</li><li>出口函数：卸载驱动程序时，就会调用该出口函数</li><li>其他完善：提供设备信息，自动创建设备节点</li></ol><h4 id="简单的hello驱动（不涉及硬件）">简单的hello驱动（不涉及硬件）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 确定主设备号 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kernel_buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b)   (a&lt;b?a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 实现对应的open、read、write函数，填入file_operation结构体 */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    copy_to_user(buf, kernel_buf, MIN(<span class="number">1024</span>, size));</span><br><span class="line">    <span class="keyword">return</span> MIN(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    copy_from_user(kernel_buf, buf, MIN(<span class="number">1024</span>, size));</span><br><span class="line">    <span class="keyword">return</span> MIN(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 定义自己的file_operation结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operation</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">    .owner  = THIS_MODULW,</span><br><span class="line">    .open   = hello_drv_open,</span><br><span class="line">    .read   = hello_drv_read,</span><br><span class="line">    .write  = hello_drv_write,</span><br><span class="line">    .release = hello_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4. 注册驱动程序，把file_operation结构体告诉内核 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5. 入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, &amp;hello_drv); </span><br><span class="line"></span><br><span class="line">    hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>); <span class="comment">/* /dev/hello */</span></span><br><span class="line">err = PTR_ERR(hello_class);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(hello_class))</span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6. 出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    device_destory(hello_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destory(hello_class);</span><br><span class="line"></span><br><span class="line">    unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. 其他完善：提供设备信息，自动创建节点 */</span></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>__FILE__</code> 是预处理器宏，用于表示当前源文件名。</li><li><code>__FUNCTION__</code> 是编译器宏，用于表示当前函数名。</li><li><code>__LINE__</code> 是预处理器宏，用于表示当前行号。</li></ul><p>这些宏常用于调试，以了解代码的执行位置。</p><ul><li><code>printk</code> 是Linux内核中用于打印调试信息的函数，类似于C标准库中的 <code>printf</code>。</li></ul><h4 id="GPIO">GPIO</h4><ol><li>使能 power/clock</li><li>选择pin’mode (pin’mode可以是uart或gpio等等)</li><li>方向：读 or 写</li><li>数据：高电平 or 低电平</li></ol><p><img src="image-20231027163401069.png" alt="GPIO"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
