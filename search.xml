<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>用户线程和内核线程区别</title>
      <link href="/2023/12/04/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/12/04/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="用户线程：">用户线程：</h3><ol><li><strong>创建和管理：</strong> 用户线程是由用户空间的应用程序创建和管理的。用户线程的创建、调度和销毁完全由用户程序的线程库（用户级线程库）负责，而不需要内核的干预。</li><li><strong>轻量级：</strong> 用户线程是轻量级的，它们的创建和上下文切换开销相对较小。因为这些线程的管理是在用户空间进行的，不需要内核介入。</li><li><strong>阻塞：</strong> 当用户线程中的一个线程被阻塞时，整个进程可能被阻塞，因为内核不了解和不管理用户线程的阻塞状态。</li><li><strong>调度：</strong> 用户线程的调度是由用户级线程库实现的，通常是基于协作式调度（cooperative scheduling）。这意味着一个用户线程在执行期间可以主动让出 CPU 控制权。</li><li><strong>无法利用多核：</strong> 由于用户线程的调度是在用户空间完成的，内核无法将不同的用户线程分配到不同的核上运行，因此用户线程不能充分利用多核处理器的优势。</li></ol><h3 id="内核线程：">内核线程：</h3><ol><li><strong>创建和管理：</strong> 内核线程是由操作系统内核创建和管理的。内核线程的创建和销毁由内核负责，而不需要用户空间的干预。</li><li><strong>重量级：</strong> 内核线程是相对重量级的，因为它们的创建和上下文切换涉及到内核的介入。这导致了相对较高的开销。</li><li><strong>阻塞：</strong> 当一个内核线程被阻塞时，通常只影响到该线程，而不会影响整个进程。其他内核线程仍然可以在系统中执行。</li><li><strong>调度：</strong> 内核线程的调度是由操作系统内核的调度器实现的，通常是基于抢占式调度（preemptive scheduling）。这意味着内核线程可以被强制剥夺 CPU 控制权。</li><li><strong>多核利用：</strong> 内核线程可以更好地利用多核处理器，因为内核可以将不同的内核线程分配给不同的核。</li></ol><h3 id="总结：">总结：</h3><ul><li>用户线程更轻量级，由用户程序自己的线程库管理，但在阻塞和调度方面有一些限制。</li><li>内核线程更重量级，由操作系统内核管理，提供更好的阻塞和调度支持，并且能够更好地利用多核处理器。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程上下文与中断上下文的区别</title>
      <link href="/2023/12/04/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/12/04/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="1-上下文切换触发时机：">1. 上下文切换触发时机：</h4><ul><li><strong>进程上下文：</strong> 进程上下文是在内核中执行进程代码时的执行环境。它通常由系统调用、中断、异常或调度程序引起。在进程上下文中，内核代码运行在进程的地址空间中。</li><li><strong>中断上下文：</strong> 中断上下文是在响应硬件中断时执行的上下文。硬件中断可以来自外部设备或是软中断触发的。中断上下文执行的代码是内核中的中断服务程序。</li></ul><h4 id="2-实时性要求：">2. 实时性要求：</h4><ul><li><strong>进程上下文：</strong> 进程上下文不要求实时性，允许较长时间的执行。因为进程上下文的切换是由操作系统的调度器控制的，可以在较长的时间间隔内完成。</li><li><strong>中断上下文：</strong> 中断上下文通常需要满足实时性的要求，因为中断服务程序必须迅速响应硬件中断。中断上下文中执行的代码应该尽量保持简短和快速。</li></ul><h4 id="3-中断屏蔽：">3. 中断屏蔽：</h4><ul><li><strong>进程上下文：</strong> 进程上下文中，中断是可以被屏蔽的。这意味着在进程上下文中执行的代码可以选择屏蔽中断，以防止中断干扰。</li><li><strong>中断上下文：</strong> 中断上下文是在中断时执行的，中断是不能被屏蔽的。中断服务程序必须响应中断，并且中断服务程序执行期间其他中断是被屏蔽的，以防止嵌套中断。</li></ul><h4 id="4-执行环境：">4. 执行环境：</h4><ul><li><strong>进程上下文：</strong> 进程上下文中，内核代码可以访问用户空间的地址空间，执行用户空间和内核空间的代码。</li><li><strong>中断上下文：</strong> 中断上下文中，内核代码只能访问内核空间，不能执行用户空间的代码。</li></ul><h4 id="5-响应性：">5. 响应性：</h4><ul><li><strong>进程上下文：</strong> 进程上下文的切换可以由操作系统的调度器控制，因此响应性较低。进程上下文切换可能需要等待调度器的调度决策。</li><li><strong>中断上下文：</strong> 中断上下文是由硬件中断引起的，响应性较高。中断服务程序迅速响应中断，不需要等待调度器。</li></ul><h4 id="总结：">总结：</h4><ul><li>进程上下文用于执行较长时间的内核代码，对实时性要求较低。</li><li>中断上下文用于迅速响应硬件中断，对实时性有较高的要求。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中断编程</title>
      <link href="/2023/12/04/Linux%E4%B8%AD%E6%96%AD%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/12/04/Linux%E4%B8%AD%E6%96%AD%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="申请和释放中断">申请和释放中断</h4><p>在Linux设备驱动中，使用中断的设备需要<strong>申请</strong>和<strong>释放</strong>对应的中断。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请中断</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放irq</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure><h4 id="底半部机制">底半部机制</h4><p>Linux实现底半部的机制主要有tasklet、工作队列、软中断、线程化irq；</p><h5 id="tasklet">tasklet</h5><p>tasklet的执行上下文是软中断，执行时机通常是顶半部返回的时候。</p><blockquote><p>软中断的执行相对于硬中断而言，更加灵活、不需要严格的实时性，并且能够在内核中执行较长时间的任务。</p></blockquote><p>使用 <code>tasklet</code> 时，一般的流程是：</p><ol><li><p><strong>注册 <code>tasklet</code>：</strong> 在驱动程序初始化阶段，通过 <code>tasklet_init()</code> 函数初始化一个 <code>tasklet</code> 结构，并通过 <code>tasklet_init()</code> 函数将其注册到内核中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_tasklet_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行 tasklet 相关的处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在初始化阶段注册 tasklet</span></span><br><span class="line">tasklet_init(&amp;my_tasklet, my_tasklet_function, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>触发 <code>tasklet</code>：</strong> 当驱动程序需要执行与 <code>tasklet</code> 相关的工作时，调用 <code>tasklet_schedule()</code> 函数触发 <code>tasklet</code> 的执行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在需要的时候触发 tasklet 执行</span></span><br><span class="line">tasklet_schedule(&amp;my_tasklet);</span><br></pre></td></tr></table></figure></li><li><p><strong>处理函数执行：</strong> 当内核下一次进入软中断上下文时，内核会检查 <code>tasklet</code> 的状态，如果处于待运行状态，就执行与之关联的处理函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_interrupt_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理中断的逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发 tasklet 执行</span></span><br><span class="line">    tasklet_schedule(&amp;my_tasklet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>总体来说，<code>tasklet_schedule()</code> 的作用是标记一个 <code>tasklet</code> 为待运行状态，以便在适当的上下文中执行与之相关的处理函数。这有助于避免在中断上下文中执行耗时的操作，从而提高系统的响应性。</p><h5 id="工作队列">工作队列</h5><p>工作队列的使用方法和<code>tasklet</code>非常相似，但是工作队列的执行上下文是内核线程，因此可以调度和睡眠。</p><p>使用 <code>工作队列</code> 时，一般的流程是：</p><ol><li><p><strong>注册工作队列：</strong> 定义一个工作队列和底半部执行函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">my_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_work_function</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行工作队列中的任务</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化和调度：</strong> 通过调用 <code>INIT_WORK</code> 宏将工作结构和处理函数关联，并通过 <code>schedule_work</code> 或 <code>queue_work</code> 函数将工作结构插入工作队列，以便在后台执行相关处理函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INIT_WORK(&amp;my_work, my_work_function);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度工作队列执行</span></span><br><span class="line">schedule_work(&amp;my_work);</span><br></pre></td></tr></table></figure></li></ol><h5 id="软中断">软中断</h5><p>软中断(Softirq)也是一种传统的底半部处理机制，它的执行时机通常是顶半部返回的时候，tasklet是基于软中断实现的，因此也运行于软中断上下文。</p><h5 id="threaded-irq">threaded_irq</h5><p><code>threaded_irq</code> 函数是 Linux 内核中用于注册<strong>线程化中断处理程序（threaded interrupt handler）的函数。</strong></p><ol><li><strong>上下文执行环境：</strong> <code>threaded_irq</code> 注册的中断处理程序在线程上下文中执行。线程上下文是在进程上下文中执行的，不要求严格的实时性，因此可以执行较长时间的任务。</li><li><strong>处理程序类型：</strong> <code>threaded_irq</code> 注册的中断处理程序是一个线程化中断处理程序。这意味着它可以执行较长时间的任务，而不会阻塞中断线。</li><li><strong>不阻塞中断线：</strong> 当 <code>threaded_irq</code> 注册的中断处理程序正在执行时，不会阻塞同一中断线上的其他中断处理程序。这允许多个中断处理程序并发执行。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常与中断</title>
      <link href="/2023/11/29/%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD/"/>
      <url>/2023/11/29/%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h4 id="异常与中断的概念与处理流程">异常与中断的概念与处理流程</h4><p><img src="image-20231129164249697.png" alt="image-20231129164249697"></p><ol><li>中断源</li><li>中断控制器</li><li>CPU</li></ol><h4 id="arm对异常-中断-处理过程：">arm对异常(中断)处理过程：</h4><ol><li><p>初始化：</p><blockquote><ol><li>设置中断源</li><li>设置中断控制器</li><li>设置CPU总开关（使能中断）</li></ol></blockquote></li><li><p>执行其他程序</p></li><li><p>产生中断：比如按下按键 --&gt; 中断控制器 --&gt; CPU</p></li><li><p>CPU每执行完一条指令都会检查有无中断/异常产生</p></li><li><p>CPU发现由中断/异常产生，开始处理。</p><blockquote><p>对于不同的异常，跳去不同的地址执行程序。该地址只有一条跳转指令，跳去执行某个函数（地址），这个就是<strong>异常向量</strong>。</p><p>异常向量表包含了一组异常处理程序的入口地址，每个异常/中断对应一个地址。当中断发生时，处理器会从异常向量表中找到相应的地址并跳转到那里执行。</p></blockquote></li><li><p>跳转的函数执行：</p><blockquote><ol><li>保存现场：各种寄存器</li><li>处理异常/中断：分辨中断源，再调用不同的处理函数。</li><li>恢复现场</li></ol></blockquote></li></ol><blockquote><p><strong>注意：上面的3，4，5都是硬件做的。</strong></p></blockquote><h4 id="Linux中断程序架构">Linux中断程序架构</h4><p><strong>中断处理原则</strong></p><ol><li>中断不能嵌套</li><li>中断处理时间越快越好</li></ol><p>但是由于中断处理程序通常比较耗时，Linux将中断处理程序分别两个半部：<strong>上半部</strong>和<strong>下半部</strong></p><p><img src="image-20231130154431818.png" alt="image-20231130154431818"></p><ul><li><p>上半部用于完成尽量少的比较紧急的任务。<strong>（通常被设计为不可被新的中断打断）</strong></p><blockquote><p>通常只是简单读取寄存器的中断状态，并在清除中断标志位后进行“登记中断“的工作，”登记中断“意味着将底半部处理程序挂到该设备的底半部执行队列中去。</p></blockquote></li><li><p>底半部几乎做了中断处理程序的所有事情。<strong>（通常被设计为可以被新的中断打断）</strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记--Linux设备驱动开发详解</title>
      <link href="/2023/11/17/%E7%AC%94%E8%AE%B0-Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/11/17/%E7%AC%94%E8%AE%B0-Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1>概述</h1><p><img src="image-20231117114308618.png" alt="image-20231117114308618"></p><p><strong>用户空间与内核空间的交互</strong></p><ul><li>应用程序可以直接使用Linux 的系统调用，也可使用C 库函数。一般都是用后者。</li></ul><p><strong>C标准库与POSIX库</strong></p><ul><li>C标准库和POSIX库都是在不同层次上提供了对操作系统功能的封装，但它们的目标和功能有所不同。</li><li>在层次结构上，可以说POSIX库在某种程度上是C标准库的扩展，增加了对系统级别的支持。因此，可以认为POSIX库更高级，因为它提供了更多的功能，但也更加特定于操作系统。</li></ul><h1>Linux 设备驱动的重点、难点</h1><ul><li>编写 Linux 设备驱动要求工程师有非常好的硬件基础，**懂得 SRAM、Flash、SDRAM、<br>磁盘的读写方式，UART、I2C、USB 等设备的接口以及轮询、中断、DMA 的原理，<br>PCI 总线的工作方式以及CPU 的内存管理单元（MMU）**等。</li><li>编写 Linux 设备驱动要求工程师有非常好的 C 语言基础，能灵活地运用 C 语言的结<br>构体、指针、函数指针及<strong>内存动态申请和释放</strong>等。</li><li>编写 Linux 设备驱动要求工程师有一定的 Linux 内核基础，虽然并不要求工程师对<br>内核各个部分有深入的研究，但**至少要明白驱动与内核的接口。尤其是对于块设<br>备、网络设备、Flash 设备、串口设备等复杂设备，**内核定义的驱动体系结构本身就<br>非常复杂。</li><li>编写 Linux 设备驱动要求工程师<strong>有非常好的多任务并发控制和同步的基础，因为在驱<br>动中会大量使用自旋锁、互斥、信号量、等待队列等并发与同步机制。</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>按键驱动</title>
      <link href="/2023/11/10/%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/11/10/%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>前言</h1><p>实现按键驱动有四种：<br>①、查询方式、————非常耗CPU<br>②、休眠-唤醒、 ———— 如果条件不满足，应用程序则一直睡眠下去<br>③、poll机制、————如果条件不满足，休眠指定的时间，休眠时间内条件满足唤醒，条件一直不满足时间到达自动唤醒<br>④、异步通知————应用程序注册信号处理函数，驱动程序发信号（signal io）</p><p><strong>驱动程序框架</strong>：</p><blockquote><p>APP: ---------------------open-------------read--------------write</p><p>————————————————————————————</p><p>驱动：--------------<strong>drv_open</strong>-------<strong>drv_read</strong>--------<strong>drv_write</strong></p><p>1️⃣     <strong>file_operation</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_openation</span> <span class="title">my_device</span> =</span> &#123;</span><br><span class="line">    .open  = drv_open,</span><br><span class="line">    .read  = drv_read,</span><br><span class="line">    .write = drv_wirte,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2️⃣<strong>register_chrdev</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">register_chrdev(major, <span class="string">&quot;name&quot;</span>, file_operation &amp;my_device); <span class="comment">//  /dev/name </span></span><br></pre></td></tr></table></figure><p>3️⃣ <strong>入口函数</strong> ——装载驱动程序时，入口函数就会自动被系统调用</p><p>4️⃣ <strong>出口函数</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>led驱动</title>
      <link href="/2023/11/07/led%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/11/07/led%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1>最简单的led驱动程序</h1><p><strong>驱动程序：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* registers */</span></span><br><span class="line"><span class="comment">// IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3地址：0x02290000 + 0x14</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3; <span class="comment">// 不可以使用物理地址来访问寄存器，一定要用虚拟地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO5_GDIR地址：0x020AC004</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> *GPIO5_GDIR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO5_DR地址：0x020AC000; 用来设置高低电平</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> *GPIO5_DR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, </span></span><br><span class="line"><span class="params">                        <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从app获得数据，设置gpio注册器的值</span></span><br><span class="line">    <span class="type">char</span> val;</span><br><span class="line">    copy_from_user(&amp;val, buf, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">    &#123;</span><br><span class="line">        *GPIO5_DR &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *GPIO5_DR |= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* enable gpio5</span></span><br><span class="line"><span class="comment">     * configure gpio5_io3 as gpio</span></span><br><span class="line"><span class="comment">     * configure gpio5_io3 as output</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 &amp;= ~<span class="number">0xf</span>;    <span class="comment">// 先清空</span></span><br><span class="line">   *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 |= ~<span class="number">0x5</span>;    <span class="comment">// 0x5 就是 101</span></span><br><span class="line"></span><br><span class="line">    *GPIO5_GDIR |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>); <span class="comment">// 因为该寄存器的第三位设为1是输出</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operation</span> <span class="title">led_fops</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open  = led_open(),</span><br><span class="line">    .write = led_write(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 入口函数 */</span></span><br><span class="line"><span class="comment">// static 表示函数仅在当前文件内可见，不能被其他文件访问。</span></span><br><span class="line"><span class="comment">// 这对于内核模块编程很重要，因为内核模块通常由多个文件组成，需要控制函数的可见性。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span>   <span class="comment">// 这只是一个普通的函数，需要用module_init来使其称为入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__)</span><br><span class="line"></span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;zwm&quot;</span>, &amp;led_fops);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ioremap */</span></span><br><span class="line">    <span class="comment">// IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3地址：0x02290000 + 0x14</span></span><br><span class="line">    IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = ioremap(<span class="number">0x02290000</span> + <span class="number">0x14</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GPIO5_GDIR地址：0x020AC004</span></span><br><span class="line">    GPIO5_GDIR = ioremap(<span class="number">0x020AC004</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GPIO5_DR地址：0x020AC000; 用来设置高低电平</span></span><br><span class="line">    GPIO5_DR = ioremap(<span class="number">0x020AC000</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    led_class =  class_create(THIS_MODULE, <span class="string">&quot;myled&quot;</span>);  <span class="comment">// 该函数用于提供一些辅助信息，系统使用这些信息创建设备节点</span></span><br><span class="line">    device_create(led_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;myled&quot;</span>); <span class="comment">// 系统会创建 /dev/myled 这一设备节点 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    iounmap(IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3);</span><br><span class="line">    iounmap(GPIO5_GDIR);</span><br><span class="line">    iounmap(GPIO5_DR);</span><br><span class="line"></span><br><span class="line">    device_destory(led_class, MKDEV(major, <span class="number">0</span>)); <span class="comment">// </span></span><br><span class="line">    class_destory(led_class);</span><br><span class="line"></span><br><span class="line">    unregister_chrdev(major, <span class="string">&quot;zwm&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(led_init); <span class="comment">// module_init 是一个宏</span></span><br><span class="line">module_exit(led_init); <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试程序：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ledtest /dev/myled on</span></span><br><span class="line"><span class="comment">// ledtest /dev/myled off</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印用法</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt; &lt;on/off&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// open </span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// fail</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// write</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;on&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd, &amp;status, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奇奇怪怪的碎碎念</title>
      <link href="/2023/11/01/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2023/11/01/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1>2023年11月份的碎碎念</h1><h2 id="11月的第一个星期">11月的第一个星期</h2><p>emotion：😭😭😭😭😭</p><p>🎸起因：新裤子北海怪兽演唱，本来没打算抢票的我，总觉得都开到家门口了，不抢怪可惜的。</p><blockquote><p>起初不打算抢票的原因：</p><ol><li>感觉新裤子越来越流行化了，觉得朋克太土了。</li><li>总觉得开演唱会太不像摇滚乐做的事儿了，摇滚乐就应该好好呆在livehouse，</li></ol><p>改变心意的原因：</p><ol><li>前一天晚上看了月夏最后一集的演唱会，朋克虽然土，但真的好容易让人回荡起被琐碎日子磨平的情绪，不用思考，没有晦涩的歌词，没有刻意制造的深刻，没有对社会的苦大仇深与抨击。我在这总是能感到裸露的情绪，为自己还能感受世界而庆幸。</li><li>第二个原因就是距离真的太近了，离学校只有不到2km的距离。</li></ol></blockquote><p>🌸经过：下午四点突然收到新裤子演唱会放票的信息，点进去一看发现280、580、780、980的票都有，我当机立断就想起前一天晚上想到如果有票的话叫上FL哥，但是之前根本没录入他们的个人身份信息，买票的时候就需要重新录入，一通下来本来可以抢到280票的我，硬生生因为录入他们的信息花了太多时间，错过280的票。此时已经很冲动了，想要去看演唱会的心情达到峰值，简单询问了一下就买了580的票乘4！！！！</p><p>🌰结果：太贵了！！太亏了！！还不能退票！！退票要收20%的手续费！！搞的FL哥和章鱼哥莫名支出了一大笔钱，关键是原本是不想看的，就算想看也是最便宜的票，一下子就比原计划多花了三百块！！！而且其实大家都互相不认识，感觉会尴尬。</p><p>而且FL哥感觉没有很想去，这波是擅自给别人做决定了，本来是打算买280的票然后就请他看的，因为冲动买票的行为导致也请不起了。</p><p>😭 导致：emo了一下午，觉得自己做事情太冲动太冲动，太不成熟，以此为鉴，得出一些结论，希望以后能减少此类事情的发生：</p><p>🌏心得：</p><ol><li><strong>提前确定好买票人，不要临时更改</strong>。如果有临时想叫的人，先管好已经定下来的，再去问别人。</li><li>提前录入买票人信息和取票地址。</li><li>不一定要一起买，不用为了连座特地一起买票，<strong>没有抢到票一切都是徒劳的</strong>。</li><li>只买最便宜一档的票！没有了就不买！因为总会等到有人出的！！</li><li>面对突如其来的票，先管自己的，再去管别人的，不带来不必要的麻烦。</li></ol><p>将该抢票心得映射到其他的事情上：</p><ol><li>不要在心急的时候做决定！不要被突如其来的计划改变乱了阵脚！如果实在计划有变，考虑此事事关自己还是事关他人，</li><li><strong>如若事关他人</strong>，则不要轻易改变计划，别人不一定能接受突然的改变，并且计划的改变通常以为着要付出代价，别人不一定能够接受这样的代价。</li><li><strong>如果事关自己</strong>，可以争取改变，毕竟自己能够承担自己做的事情带来的代价。</li></ol><p>这次就算了，好好享受这一场演唱会，想太多也没有用，期待演出捏</p><p><img src="image-20231101210351116.png" alt="image-20231101210351116"></p><p>最后附上新裤子的一首歌，歌名与今日感受十分贴切，🎧   ----&gt;  <a href="https://music.163.com/#/song?id=2033879001">荒废的一天</a></p><p>END/</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 本人的碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驱动开发框架</title>
      <link href="/2023/10/26/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/10/26/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="目录">目录</h4><ul><li>通用驱动框架</li><li>简单的hello驱动</li><li>GPIO</li></ul><h4 id="通用驱动框架">通用驱动框架</h4><ol><li>确定主设备号</li><li>定义自己的<code>file_operator</code>结构体</li><li>实现对应的<code>open\read\write</code>等函数，填入<code>file_operator</code>结构体</li><li>把<code>file_operator</code>结构体告诉内核：注册驱动程序</li><li>入口函数：安装驱动程序时就会调用该入口函数</li><li>出口函数：卸载驱动程序时，就会调用该出口函数</li><li>其他完善：提供设备信息，自动创建设备节点</li></ol><h4 id="简单的hello驱动（不涉及硬件）">简单的hello驱动（不涉及硬件）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 确定主设备号 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kernel_buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b)   (a&lt;b?a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 实现对应的open、read、write函数，填入file_operation结构体 */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    copy_to_user(buf, kernel_buf, MIN(<span class="number">1024</span>, size));</span><br><span class="line">    <span class="keyword">return</span> MIN(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    copy_from_user(kernel_buf, buf, MIN(<span class="number">1024</span>, size));</span><br><span class="line">    <span class="keyword">return</span> MIN(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 定义自己的file_operation结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operation</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">    .owner  = THIS_MODULW,</span><br><span class="line">    .open   = hello_drv_open,</span><br><span class="line">    .read   = hello_drv_read,</span><br><span class="line">    .write  = hello_drv_write,</span><br><span class="line">    .release = hello_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4. 注册驱动程序，把file_operation结构体告诉内核 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5. 入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, &amp;hello_drv); </span><br><span class="line"></span><br><span class="line">    hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>); <span class="comment">/* /dev/hello */</span></span><br><span class="line">err = PTR_ERR(hello_class);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(hello_class))</span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6. 出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    device_destory(hello_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destory(hello_class);</span><br><span class="line"></span><br><span class="line">    unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. 其他完善：提供设备信息，自动创建节点 */</span></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>__FILE__</code> 是预处理器宏，用于表示当前源文件名。</li><li><code>__FUNCTION__</code> 是编译器宏，用于表示当前函数名。</li><li><code>__LINE__</code> 是预处理器宏，用于表示当前行号。</li></ul><p>这些宏常用于调试，以了解代码的执行位置。</p><ul><li><code>printk</code> 是Linux内核中用于打印调试信息的函数，类似于C标准库中的 <code>printf</code>。</li></ul><h4 id="GPIO">GPIO</h4><ol><li>使能 power/clock</li><li>选择pin’mode (pin’mode可以是uart或gpio等等)</li><li>方向：读 or 写</li><li>数据：高电平 or 低电平</li></ol><p><img src="image-20231027163401069.png" alt="GPIO"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
